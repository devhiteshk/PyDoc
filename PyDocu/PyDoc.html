<script src="https://cdn.freecodecamp.org/testable-projects-fcc/v1/bundle.js"></script>

<!DOCTYPE html >
<html lang="en-us">

<head>
    <title>Python Basics</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="author" content="Hitesh Kumar">
    <meta name="description" content="Python Basics">
    <link rel="preconnect" href="https://fonts.gstatic.com">
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@300;400&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="./css/style.css" type="text/css">
</head>

<body>
    <div class="module-border-wrap">
        <div class="module" id="technical-doc-div">

            <nav id="navbar">
                <header id="index-header">

                    <h1 id="main-heading">Python Basics</h1>
                    <h4 class="navbar-headings"> <a class="nav-link" href="#Pythonw1">About Python</a></h4>
                    <h4 class="navbar-headings"> <a class="nav-link" href="#week1">Week 1: First Program</a></h4>
                    <h4 class="navbar-headings"> <a class="nav-link" href="#week2">Week 2: Data Types</a></h4>
                    <h4 class="navbar-headings"> <a class="nav-link" href="#week3">Week 3: Conditionals</a></h4>
                    <h4 class="navbar-headings"> <a class="nav-link" href="#week4">Week 4: Loops</a></h4>
                    <h4 class="navbar-headings"> <a class="nav-link" href="#week5">Week 5: Functions</a></h4>
                    <h4 class="navbar-headings"> <a class="nav-link" href="#week6">Week 6: Dictionaries</a></h4>
                    <h4 class="navbar-headings"> <a class="nav-link" href="#week7">Week 7: OOPs</a></h4>
                    <h4 class="navbar-headings"> <a class="nav-link" href="#week8">Week 8: Efficiency 1</a></h4>
                    <h4 class="navbar-headings"> <a class="nav-link" href="#week9">Week 9: Efficiency 2</a></h4>
                    <h4 class="navbar-headings"> <a class="nav-link" href="#week10">Week 10: Data Analysis</a></h4>
                    <h4 class="navbar-headings"> <a class="nav-link" href="#about">About</a></h4>
                </header>
            </nav>
            <main id="main-doc">
                <article>
                    <section id="Pythonw1" class="main-section">
                        <header>
                            <h2>Python</h2>
                        </header>
                        <p class="support-text">
                            Python is a widely used general-purpose, high level programming language. It was created by Guido van Rossum in 1991 and further developed by the Python Software Foundation. It was designed with an emphasis on code readability, and its syntax allows programmers
                            to express their concepts in fewer lines of code. Python is a programming language that lets you work quickly and integrate systems more efficiently. There are two major Python versions: Python 2 and Python 3. Both are quite
                            different.
                        </p>
                        <p class="support-text">
                            Its language constructs and object-oriented approach aim to help programmers write clear, logical code for small and large-scale projects. Python is dynamically-typed and garbage-collected. It supports multiple programming paradigms, including structured,
                            object-oriented and functional programming. Python is often described as a "batteries included" language due to its comprehensive standard library.
                        </p>
                        <p class="support-text">
                            The language's core philosophy is summarized in the document The Zen of Python (PEP 20), which includes aphorisms such as:
                            <ul>
                                <li> Beautiful is better than ugly.</li>
                                <li> Explicit is better than implicit.</li>
                                <li> Simple is better than complex.</li>
                                <li> Complex is better than complicated.</li>
                                <li> Readability counts.</li>
                            </ul>
                            Rather than having all of its functionality built into its core, Python was designed to be highly extensible. This compact modularity has made it particularly popular as a means of adding programmable interfaces to existing applications.
                        </p>
                        <p class="support-text ">
                            <b> Python's statements include (among others):</b><br/> The assignment statement, using a single equals sign =.<br />
                            <br /> The if statement, which conditionally executes a block of code, along with else and elif (a contraction of else-if).<br />
                            <br /> The for statement, which iterates over an iterable object, capturing each element to a local variable for use by the attached block.<br />
                            <br /> The while statement, which executes a block of code as long as its condition is true.<br />
                            <br /> The try statement, which allows exceptions raised in its attached code block to be caught and handled by except clauses; it also ensures that clean-up code in a finally block will always be run regardless of how the
                            block exits.<br />
                            <br /> The raise statement, used to raise a specified exception or re-raise a caught exception.<br />
                            <br /> The class statement, which executes a block of code and attaches its local namespace to a class, for use in object-oriented programming.<br />
                            <br /> The def statement, which defines a function or method.<br />
                            <br /> The with statement, from Python 2.5 released in September 2006, which encloses a code block within a context manager (for example, acquiring a lock before the block of code is run and releasing the lock afterwards, or
                            opening a file and then closing it), allowing resource-acquisition-is-initialization (RAII)-like behavior and replaces a common try/finally idiom.<br />
                            <br /> The break statement, exits from a loop.<br />
                            <br /> The continue statement, skips this iteration and continues with the next item.<br />
                            <br /> The del statement, removes a variable, which means the reference from the name to the value is deleted and trying to use that variable will cause an error. A deleted variable can be reassigned.<br />
                            <br /> The pass statement, which serves as a NOP. It is syntactically needed to create an empty code block.<br />
                            <br /> The assert statement, used during debugging to check for conditions that ought to apply.<br />
                            <br /> The yield statement, which returns a value from a generator function. From Python 2.5, yield is also an operator. This form is used to implement coroutines.<br />
                            <br /> The return statement, used to return a value from a function.<br />
                            <br> The import statement, which is used to import modules whose functions or variables can be used in the current program. <br /> <br /> There are three ways of using import:
                            <br />
                            <li> import libname</li>
                            <li> import libname as name</li>
                            <li> from libname import function as name</li>
                            <br /> The assignment statement (=) operates by binding a name as a reference to a separate, dynamically-allocated object.<br />
                            <br /> Variables may be subsequently rebound at any time to any object. In Python, a variable name is a generic reference holder and doesn't have a fixed data type associated with it. However at a given time, a variable will
                            refer to some object, which will have a type. This is referred to as dynamic typing and is contrasted with statically-typed programming languages, where each variable may only contain values of a certain type. Python does not
                            support tail call optimization or first-class continuations, and, according to Guido van Rossum, it never will. However, better support for coroutine-like functionality is provided in 2.5, by extending Python's generators.
                            Before 2.5, generators were lazy iterators; information was passed unidirectionally out of the generator. From Python 2.5, it is possible to pass information back into a generator function, and from Python 3.3, the information
                            can be passed through multiple stack levels.
                        </p>
                    </section>
                    <section id="week1" class="main-section">
                        <header>
                            <h2> Week 1</h2>
                        </header>
                    </section>
                    <p class="support-text">
                        <br /> help() to get help from online documentation
                        <br /> # this is 2nd line of the program
                        <br /> # this is third line of the program<br />

                        <br /> # week 1 "FIRST PROGRAM"<br />

                        <br /> # Guessing Game<br />
                        <br /> from random import randint
                        <br /> from IPython.display import clear_output
                        <br /> guessed = False
                        <br /> number = randint(0,100)
                        <br /> guesses = 0
                        <br /> while not guessed:
                        <br /> <span class="tab"></span>ans = input("Try to guess the number i am thinking of")
                        <br /> <span class="tab"></span># use tab to indent
                        <br /> <span class="tab"></span>guesses + = 1
                        <br /><span class="tab"></span>clear_output()
                        <br /><span class="tab"></span>if int(ans) == number:
                        <br /><span class="tab"></span><span class="tab"></span> print("congrats! you guessed it correctly")
                        <br /><span class="tab"></span>print('if you took { } guesses1'.format(guesses) )
                        <br /><span class="tab"></span>break
                        <br /><span class="tab"></span>elif int(ans) > number:
                        <br /><span class="tab"></span><span class="tab"></span> print("The number is lower than what you guessed.")
                        <br /><span class="tab"></span>elif int(ans)
                        < number: <br /><span class="tab"></span><span class="tab"></span> print("The number is greater than what you guessed.")<br />
                        <br /> DON'T WORRY if you can't understand the code just go ahead and run the program in Pycharm or any other IDE.<br /> <br /> Download <a href="https://www.jetbrains.com/pycharm/download/" id="Pycharm"> Pycharm IDE</a> and
                        <a href="https://www.python.org/downloads/" id="PythonDown"> Python</a>
                    </p>

                    <section id="week2" class="main-section">
                        <header>
                            <h2> Week 2</h2>
                        </header>
                        <p class="support-text">

                            <br /> <b> # COMMENTS AND BASIC DATA TYPES</b>
                            <br />
                            <br /> # this is a comment
                            <br />
                            <br /> print("hello") #A print statement
                            <br />
                            <br /> """
                            <br /> This is a multiline comment
                            <br /> """
                            <br />
                            <br /> # Data Types are Integers Float Boolean String
                            <br /> # 5 5.7 true "hii"
                            <br />
                            <br /> # following are all integers
                            <br /> print(2)
                            <br /> print(10)
                            <br />
                            <br /> # following are all floats
                            <br /> print(10.935)
                            <br /> print(8.0)

                            <br /> # the following are all boleans
                            <br /> print(True)
                            <br /> print(False)
                            <br />
                            <br /> # following are the strings
                            <br /> print("") # print a empty line
                            <br /> print("there's a snake in my boot!")
                            <br /> print('True')
                            <br />
                            <br /> # MONDAY EXERCISE
                            <br /> print("Hitesh Kumar")
                            <br /> print(type(int)) # will output class 'int'<br />
                            <br /> # TUESDAY : VARIABLES<br />

                            <br /> first_name = "John" # A str data type is stored in first_name

                            <br /> # integer and float variables

                            <br /> num1 = 5 # storing int type in num1
                            <br /> num2 = 8.4 # storing float type in num2
                            <br /> print(num1, num2)

                            <br /> # Boolean variables

                            <br /> # storing boolean into a variable
                            <br /> switch = True
                            <br /> print(switch)

                            <br /> # STRING variables<br />


                            <br /> # storing string into a variable
                            <br /> name = 'John Smith'
                            <br /> fav_number = '9'
                            <br /> print(name, fav_number) # will print 9 next to the name
                            <br />
                            <br /> # Using multiple variables to create another variable
                            <br /> result = num1 + num2
                            <br /> print(result)
                            <br />
                            <br /> # USING OPERATORS ON NUMERICALS VARIABLES
                            <br />
                            <br /> # Adding, deleting, multiplying, dividing, from a variable
                            <br /> result + = 1 # same as saying result = result +1
                            <br /> print(result)
                            <br /> result *= num1 # same as saying result = result * num1
                            <br /> print(result)
                            <br />

                            <br /> # Overwriting previously created variables
                            <br />
                            <br /> # defining a variable and overwriting it's value
                            <br />
                            <br /> name = 'John'
                            <br /> print(name)
                            <br /> name = 'Sam'
                            <br /> print(name)
                            <br />
                            <br /> # WHITESPACE
                            <br /> name = 'John Smith'
                            <br />
                            <br /> # Tuesday Exercise
                            <br /> # 1 calculating product of two numbers and giving out result
                            <br /> x = 3
                            <br /> y = 10
                            <br /> result = x*y
                            <br /> print(x,'+',y,'=',result)
                            <br />
                            <br /> # Area calculation
                            <br /> L = 245.54
                            <br /> B = 13.66
                            <br /> result = L*B
                            <br /> print('Area of Rectangle is =',result)
                            <br />
                            <br /> # WEDNESDAY : Working with strings
                            <br />
                            <br /> # string Concatenation
                            <br /> name = "John" + " " + "Smith"
                            <br /> print(name)
                            <br />
                            <br /> first_name = "john"
                            <br /> last_name = "Smith"
                            <br /> full_name = first_name + " " + last_name
                            <br /> print(full_name)
                            <br />
                            <br /> # Fomatting strings
                            <br />
                            <br /> # .format()
                            <br /> # injecting variables using the format method
                            <br /> name = "John"
                            <br /> print("Hello {}".format(name) )
                            <br /> print("Hello {}, you are {} years old!".format(name,28))
                            <br />
                            <br /> # f Strings
                            <br /> # using the new fstring in python
                            <br /> name = "John"
                            <br /> print(f"Hello{name}")
                            <br />
                            <br /> # In Python 2
                            <br /> # python 2 multiple variable formatting
                            <br /> first_name = "John"
                            <br /> last_name = "Smith"
                            <br /> print( "Hello, %s %s" % (first_name, last_name) )
                            <br /> # surround the variables in parenthesis
                            <br />
                            <br /> # STRING INDEX<br />
                            <br /> # in python index staets with 0
                            <br />
                            <br /> # Using indexes to print each element
                            <br /> word = "Hello"
                            <br /> print( word[0]) # will output 'H'
                            <br /> print( word[1]) # will output 'e'
                            <br /> print( word[-1]) # will output 'o' the last element of string
                            <br />
                            <br /> # String Slicing
                            <br /> print( word[0:2]) # will output He
                            <br />
                            <br /> # variable_name[start : stop : step]
                            <br /> print( word[0:5:2]) # will output 'Hlo'
                            <br />
                            <br /> # Wednesday Exercise
                            <br /> # 1
                            <br />
                            <br /> print("{} years old {} inch. tall man gave {} statement his name is {}".format(23,4.5,False,name))

                            <br /> print("{}'s favourite sports is {}.".format('Hitesh','Cricket'))
                            <br /> print("{}'s is working on {} programming!".format('Deepak','Py4e'))
                            <br />

                            <br /> # THURSDAY String manipulation<br />
                            <br /> # .title()
                            <br /> # using the title method to capitalize a string

                            <br /> name = "john smith"
                            <br /> print( name.title()) # Gives John Smith
                            <br /> print( name.lower()) # All lower case
                            <br /> print( name.upper()) # All upper
                            <br />
                            <br /> # .replace()<br />
                            <br /> # replacing an exclamation point with a period
                            <br /> words = "Hello there!"
                            <br /> print( words.replace( "!", "." ) ) # replace ! with .
                            <br /> words = words.replace('!','.')

                            <br />
                            <br /> # .find()
                            <br /> # finding the starting index of our searched ter
                            <br /> s = "Look over that way"
                            <br /> print(s.find("over")) # returns starting position of over
                            <br />
                            <br /> # .strip()<br />
                            <br /> # removing white space with strip
                            <br /> name = " john "
                            <br /> print(name.strip()) # removes spaces from both sides
                            <br /> print(name.lstrip()) # removes spaces from left side
                            <br /> print(name.rstrip()) # removes spaces from right side

                            <br />
                            <br /> # .split()<br />
                            <br /> # converting a string into a list of words
                            <br /> s = "These words are separated by spaces"
                            <br /> print( s.split(" "))<br />

                            <br /> # Thursday exercises<br />
                            <br /> # 1 Uppercasing
                            <br /> st = "uppercase"
                            <br /> print(st.upper())
                            <br />
                            <br /> # 2 Strip symbols<br />
                            <br /> c = "$$John Smith"
                            <br /> print(c.strip("John Smith"))
                            <br /> print(c.strip("JohnSmit "))
                            <br /> print(c.lstrip("$$"))
                            <br />
                            <br /> # Challenge : Reverse a String by Slice<br />
                            <br /> AN = "Hello"
                            <br /> print(AN[::-1])
                            <br />
                            <br />
                            <br /> # Friday Project : Receipt Printing Program<br />

                            <br /> # step 1 : Define Variables<br />
                            <br /> p1_name, p1_price = "Books", 49.95
                            <br /> p2_name, p2_price = "Computer", 579.99
                            <br /> p3_name, p3_price = "Monitor", 124.89<br />

                            <br /> # step 2 : Create company name and information<br />
                            <br /> company_name = "Coding Temple, inc."
                            <br /> company_address = "283 Franklin St."
                            <br /> company_city = "Boston, MA"<br />

                            <br /> # step 3 : Declare ending message<br />
                            <br /> message = "Thanks for shopping with us today!"<br />

                            <br /> # step 4 : Creating top border<br />
                            <br /> print("*" *50)<br />

                            <br /> # Step 5 : displaying company information<br />
                            <br /> print("*\t\t\t\t{}\t\t\t\t *".format(company_name.title()))
                            <br /> print("*\t\t\t\t{}\t\t\t\t *".format(company_address.title()))
                            <br /> print("*\t\t\t\t{}\t\t\t\t\t\t *".format(company_city.title()))<br />

                            <br /> # Step 6 : print a line between sections<br />
                            <br /> print("=" *50)<br />

                            <br /> # step 7 : Displaying the product Information<br />
                            <br /> print("*\t\tProduct Name\t\tProduct price\t\t *")
                            <br /> print("*\t\t{}\t\t\t\t${}\t\t\t\t *".format(p1_name.title(),p1_price))
                            <br /> print("*\t\t{}\t\t\t${}\t\t\t\t *".format(p2_name.title(),p2_price))
                            <br /> print("*\t\t{}\t\t\t\t${}\t\t\t\t *".format(p3_name.title(),p3_price))<br />

                            <br /> # step 8 : line between section<br />
                            <br /> print("*" *50)<br />

                            <br /> # step 9 : Total<br />
                            <br /> total = p1_price + p2_price + p3_price
                            <br /> print("*\t\t\t\t\t\t\tTotal\t\t\t\t *")
                            <br /> print("*\t\t\t\t\t\t\t${}\t\t\t\t *".format(total))<br />

                            <br /> # step 10 : Print a line between section<br />
                            <br /> print("=" *50)<br />

                            <br /> # step 11 : end message<br />
                            <br /> print("*\t\t{}\t\t *".format(message))<br />

                            <br /> # step 11 : Line between section<br />
                            <br /> print("*" *50)<br />

                            <br /> # program completed
                        </p>
                    </section>
                    <section id="week3" class="main-section">
                        <header>
                            <h2> Week 3</h2>
                        </header>
                        <p id="main section">
                            # User Input and Conditionals<br />
                            <br />
                            <br /> # accepting and outputting user input<br />
                            <br /> print( input("What is your name? ") )<br />

                            <br /> # saving what the user inputs<br />
                            <br /> ans = input("What is your name? ")
                            <br /> print("Hello {}!".format(ans) )<br />

                            <br /> # checking data type<br />
                            <br /> num = 5
                            <br /> print(type(num))<br />

                            <br /> # converting data types<br />
                            <br /> num = "9"
                            <br /> num = int(num)
                            <br /> print(type(num))<br />

                            <br /> # working with user input to perform calculations<br />
                            <br /> ans = input("Type a number to add: ")
                            <br /> print( type(ans) ) # default type is string, must convert
                            <br /> result = 100 + int(ans)
                            <br /> print( "100 + {} = {}".format(ans, result))<br />


                            <br /> # using the try and except blocks, use tab to indent where necessary<br />
                            <br /> try:
                            <br /> <span class="tab"></span>ans = float( input("Type a number to add: ") )
                            <br /><span class="tab"></span> print( "100 + {} = {}".format(ans, 100 + ans) )
                            <br /> except:
                            <br /> <span class="tab"></span>print("You did not put in a valid number!")
                            <br /> <span class="tab"></span># without try/except print statement would not get hit if error occurs
                            <br /> <span class="tab"></span>print("The program did not break!")<br />
                            <br /> # Monday Exercise<br />
                            <br /> y = input("Year")
                            <br /> c = input("colour")
                            <br /> m = input("model")
                            <br /> print("{} {} {}".format(y,c,m))<br />
                            <br /> # Tuesday : IF STATEMENTS

                            <br /> # using an if statement to only run code if the condition is met<br />
                            <br /> x, y = 5, 10
                            <br /> if x
                            < y: <br /> <span class="tab"></span>print("x is less than y")<br />

                            <br /> # Checking user input<br />
                            <br /> ans = int(input("what is 5 + 5? "))
                            <br /> if ans == 10:
                            <br /> <span class="tab"></span>print("you got it right!")<br />


                            <br /> # LOGICAL OPERATORS
                            <br /> # AND<br />

                            <br /> x, y, z = 5, 10, 5
                            <br /> if x &lt;y and x == z:<br />
                            <br /> <span class="tab"></span>print("both statements were true")<br />
                            <br /> # OR operator<br />
                            <br /> x, y, z=5, 10, 5
                            <br /> <span class="tab"></span>if x&lt;y or x!=z:
                            <br /> print("One or Both statements were true")<br />

                            <br /> # NOT operator<br />
                            <br /> flag = False
                            <br /> if not flag: # same as if flag==False
                            <br /> <span class="tab"></span>print("Flag is False")<br />

                            <br /> # MEMBERSHIP operator
                            <br /> # IN<br />

                            <br /> word = "Baseball"
                            <br /> if "b" in word:
                            <br /> <span class="tab"></span>print("{} contains the character b".format(word))<br />

                            <br /> # NOT IN<br />
                            <br /> if "x" not in word:
                            <br /> <span class="tab"></span>print("{} does not contain the character x".format(word))<br />
                            <br /># Week 3 Tuesday exercise<br />
                            <br />word = input("Enter a sentence:\n ")
                            <br />if "es" in word:
                            <br /><span class="tab"></span>print("{} contains 'es' in it".format(word))

                            <br />wo2 = input("Enter a sentence:\n ")
                            <br />print(wo2[-3::1])
                            <br />if "ing" in wo2[-3::1]:
                            <br /> <span class="tab"></span>print("{} contains ing in the end".format(wo2))

                            <br />two_words = input("Enter 2 words:\n")
                            <br />words = two_words.split(" ")
                            <br />if words[0].lower() == words[1].lower():
                            <br /> <span class="tab"></span>print("both are same words")

                            <br />num = input("Enter a number:\n")
                            <br />num = int(num)
                            <br />if num
                            <10: <br /> <span class="tab"></span>print("square of number is: ",num*num)<br />
                            <br /># Wednesday elif statements<br />
                            <br />x, y = 5, 10
                            <br />if x > y:
                            <br /> <span class="tab"></span>print("x is greater")
                            <br />elif x
                            < y: <br /> <span class="tab"></span>print("x is less")<br />

                            <br /># Multiple elif conditions<br />
                            <br />x, y = 5, 10
                            <br />if x > y:
                            <br /> <span class="tab"></span>print("x is greater")
                            <br />elif (x+10)
                            < y: <br /> <span class="tab"></span>print("x is less")
                            <br />elif (x+5) == y:
                            <br /> <span class="tab"></span>print("equal")<br />

                            <br /># Conditionals within conditionals<br />
                            <br />x, y, z = 5, 10, 5
                            <br />if x > y:
                            <br /> <span class="tab"></span>print("greater")
                            <br />elif x
                            <=y : <br /> <span class="tab"></span>if x == z:
                            <br /> <span class="tab"></span><span class="tab"></span>print("x is equal to z")
                            <br /> <span class="tab"></span>elif x != z:
                            <br /> <span class="tab"></span><span class="tab"></span>print("x is not equal to z")<br />

                            <br /># testing output of two if statements in a row that are both true<br />
                            <br />x, y, z = 5, 10, 5
                            <br />if x
                            < y: <br /> <span class="tab"></span>print("x is less")
                            <br />if x == z:
                            <br /> <span class="tab"></span>print("x is equal")<br />

                            <br /># testing output of an if and elif statement that are both true<br />
                            <br />x, y, z = 5, 10, 5
                            <br />if x
                            < y: <br /> <span class="tab"></span>print("x is less")
                            <br />elif x == z:
                            <br /> <span class="tab"></span>print("x is equal to z")<br />

                            <br /># Wednesday Exercise<br />

                            <br />num = int(input("Enter a number"))
                            <br />if num
                            < 100: <br /> <span class="tab"></span>print("{} is lower than 100".format(num))
                            <br />elif num > 100:
                            <br /> <span class="tab"></span>print("{} is greater than 100".format(num))<br />

                            <br />x, y = 5, 10
                            <br />if x > y:
                            <br /> <span class="tab"></span>print("greater")
                            <br />elif x
                            < y: <br /> <span class="tab"></span>print("lower")<br />

                            <br /># THURSDAY : Else statement<br />
                            <br />name = "John"
                            <br />if name == "Jacob":
                            <br /> <span class="tab"></span>print("Hello Jacob!")
                            <br />else:
                            <br /> <span class="tab"></span>print("Hello {}!".format(name))<br />

                            <br /># Completing Conditional Statement<br />
                            <br />name = "John"
                            <br />if name[0] == "A":
                            <br /> <span class="tab"></span>print("name starts with A")
                            <br />elif name[0] == "B":
                            <br /> <span class="tab"></span>print("Name starts with B")
                            <br />elif name[0] == "J":
                            <br /> <span class="tab"></span>print("Nmae starts with J")
                            <br />else :
                            <br /> <span class="tab"></span>print("Name starts with {}".format(name[0]))<br />

                            <br /># THURSDAY Exercise:<br />
                            <br />name = "John"
                            <br />if name == "Jack":
                            <br /> <span class="tab"></span>print("Hello Jack")
                            <br />else:
                            <br /> <span class="tab"></span>print("Hello John")<br />

                            <br />tim = int(input("Enter the time:\n"))
                            <br />if tim
                            < 1200: <br /> <span class="tab"></span>print("Good morning")
                            <br />elif tim == 1200 or tim
                            <1700: <br /> <span class="tab"></span>print("Good Afternoon")
                            <br />else:
                            <br /> <span class="tab"></span>print("good evening")<br />
                            <br /># Challenge question with 2 story lines<br />
                            <br />print(" What you would like to choose!\n1. AGE GROUP\n2. CALCULATOR")
                            <br />print("Choose 1 or 2")
                            <br />choose = input()
                            <br />if choose == "1":

                            <br /> <span class="tab"></span>Age = float(input("Enter the age to know your age group:\t"))
                            <br /> <span class="tab"></span>print("Your age is {}".format(Age))
                            <br /> <span class="tab"></span>if 0
                            < Age <=1 2: <br /> <span class="tab"></span><span class="tab"></span>print("Kid")
                            <br /> <span class="tab"></span>elif 13
                            <=A ge <=1 9: <br /> <span class="tab"></span><span class="tab"></span>print("Teenager")
                            <br /> <span class="tab"></span>elif 20
                            <=A ge <=3 0: <br /> <span class="tab"></span><span class="tab"></span>print("Young Adult")
                            <br /> <span class="tab"></span>elif 31
                            <=A ge <=6 4: <br /> <span class="tab"></span><span class="tab"></span>print("Adult")
                            <br /> <span class="tab"></span>elif Age >= 65:
                            <br /> <span class="tab"></span><span class="tab"></span>("Senior")
                            <br /> <span class="tab"></span>else:
                            <br /> <span class="tab"></span><span class="tab"></span>print("Error: Please enter a valid age")<br />

                            <br /># FRIDAY: CREATING A CALCULATOR<br />

                            <br /># step 1: ask user for calculation to be performed<br />
                            <br />elif choose == "2":

                            <br /> <span class="tab"></span>operation = input("Would you like to add/subtract/multiply/divide?:\n").lower()
                            <br /> <span class="tab"></span>print("You have chosen to {}".format(operation))<br />

                            <br /> # Step 2 : ask for number inputs<br />
                            <br /> <span class="tab"></span>if operation == "subtract" or operation == "divide":
                            <br /> <span class="tab"></span><span class="tab"></span>print("you chose {}".format(operation))
                            <br /> <span class="tab"></span> <span class="tab"></span>print("Please keep in mind that order matters.")
                            <br />
                            <<span class="tab"></span>span class="tab"></span>num1 = input("Enter the first number: \t")
                                <br /><span class="tab"></span><span class="tab"></span>num2 = input("Enter the second number: \t")
                                <br /><span class="tab"></span><span class="tab"></span>print("First Number : {}".format(num1))
                                <br /><span class="tab"></span><span class="tab"></span>print("Second Number : {}".format(num2))<br />

                                <br /><span class="tab"></span># Ask to reverse the order of number<br />

                                <br /><span class="tab"></span><span class="tab"></span>order = input("Do you want to reverse the order of number: Y/N\t")
                                <br /><span class="tab"></span><span class="tab"></span>if order == "Y":
                                <br /><span class="tab"></span> <span class="tab"></span><span class="tab"></span>num3 = num1
                                <br /> <span class="tab"></span><span class="tab"></span><span class="tab"></span>num1 = num2
                                <br /> <span class="tab"></span> <span class="tab"></span><span class="tab"></span>num2 = num3
                                <br /> <span class="tab"></span><span class="tab"></span> <span class="tab"></span>print("corrected order is\nNumber 1: {} \nNumber 2: {}".format(num1, num2))
                                <br /> <span class="tab"></span><span class="tab"></span>elif order == "N":
                                <br /> <span class="tab"></span> <span class="tab"></span><span class="tab"></span>num1 = num1
                                <br /> <span class="tab"></span> <span class="tab"></span><span class="tab"></span>num2 = num2<br />

                                <br /># step 3: Set up try/ except for mathematical operation<br />

                                <br /><span class="tab"></span><span class="tab"></span>try:
                                <br /> <span class="tab"></span><span class="tab"></span><span class="tab"></span># convert to float
                                <br /> <span class="tab"></span><span class="tab"></span><span class="tab"></span>num1, num2 = float(num1), float(num2)
                                <br /> <span class="tab"></span><span class="tab"></span><span class="tab"></span>if operation == "add":
                                <br /> <span class="tab"></span><span class="tab"></span> <span class="tab"></span><span class="tab"></span>result = num1 + num2
                                <br /> <span class="tab"></span><span class="tab"></span><span class="tab"></span>print("{} + {} = {}".format(num1, num2, result))
                                <br /> <span class="tab"></span><span class="tab"></span><span class="tab"></span>elif operation == "subtract":
                                <br /> <span class="tab"></span> <span class="tab"></span> <span class="tab"></span><span class="tab"></span>result = num1 - num2
                                <br /> <span class="tab"></span> <span class="tab"></span> <span class="tab"></span><span class="tab"></span>print("{} - {} = {}".format(num1, num2, result))
                                <br /><span class="tab"></span> <span class="tab"></span> <span class="tab"></span>elif operation == "multiply":
                                <br /><span class="tab"></span> <span class="tab"></span> <span class="tab"></span><span class="tab"></span>result = num1*num2
                                <br /> <span class="tab"></span><span class="tab"></span> <span class="tab"></span><span class="tab"></span>print("{} * {} = {}".format(num1, num2, result))
                                <br /><span class="tab"></span><span class="tab"></span><span class="tab"></span>elif operation == "divide":
                                <br /><span class="tab"></span><span class="tab"></span> <span class="tab"></span><span class="tab"></span>result = num1/num2
                                <br /> <span class="tab"></span><span class="tab"></span> <span class="tab"></span><span class="tab"></span>print("{}/{} = {}".format(num1, num2, result))
                                <br /><span class="tab"></span> <span class="tab"></span><span class="tab"></span>else:
                                <br /><span class="tab"></span> <span class="tab"></span> <span class="tab"></span><span class="tab"></span>print("Sorry but {} is not an option.".format(operation))

                                <br /><span class="tab"></span><span class="tab"></span>except:
                                <br /><span class="tab"></span><span class="tab"></span><span class="tab"></span>print("Error: Improper numbers used. Please try again.")

                                <br />else:
                                <br /> <span class="tab"></span>print("ERROR: Please choose between 1 and 2 only")<br />
                        </p>
                    </section>
                    <section id="week4" class="main-section">
                        <header>
                            <h2>Week 4</h2>
                        </header>
                        <p class="support-text">
                            <br /># Lists and Loops
                            <br />
                            <br /> # declaring a list of numbers
                            <br />nums = [5, 10, 15.2, 20]
                            <br />print(nums)
                            <br />
                            <br /> # accessing elements within a list
                            <br/>print(nums[1])
                            <br/>num = nums[2]
                            <br/>print(num)
                            <br/>
                            <br/># declaring a list of mixed data types
                            <br/>num = 4.3
                            <br/>data = [num, "word", True]
                            <br/>print(data)
                            <br/>
                            <br/># list within lists
                            <br/>data = [5, "book", [34, "hello"], True]
                            <br/>print(data)
                            <br/>print(data[2])
                            <br/>
                            <br/># Accessing lists within lists
                            <br/>print(data[2][0])
                            <br/>print(data[2][1])
                            <br/>print(data[2][1][0])
                            <br/>
                            <br/># changing values in a list
                            <br/>data = [5, 10, 15, 20]
                            <br/>print(data)
                            <br/>data[0] = 100
                            <br/>print(data)
                            <br/>
                            <br/># Variable storage in ID
                            <br/>a = [5, 10]
                            <br/>print(id(a))
                            <br/>
                            <br/># Understanding how lists are sorted
                            <br/>a = [5, 10]
                            <br/>b = a
                            <br/>print("a: {}\t b: {}".format(a, b))
                            <br/>print("location a[0]: {}\t location b[0]: {}". format(id(a[0]), id(b[0])))
                            <br/>a[0] = 20 <span class="tab"></span> # # re-declaring the value of a[0] also changes b[0]
                            <br/>print("a: {}\t b: {}".format(a, b))
                            <br/>
                            <br/># COPYING A LIST<br/>
                            <br/># using [:] to copy a list
                            <br/>data = [5, 10, 15, 20]
                            <br/>data_copy = data[:] <span class="tab"></span> # a single colon copies the list
                            <br/>data[0] = 50
                            <br/>print("data: {}\t data_copy: {}".format(data, data_copy))
                            <br/>data_c_method = data_copy.copy()
                            <br/>print("data_c_copy: {}".format(data_c_method))
                            <br/>
                            <br/>
                            <br/># MONDAY EXERCISE
                            <br/>
                            <br/># 1
                            <br/>sports = ["cricket", "basketball", "football", "chess"]
                            <br/>print("i like to play {}".format(sports[0]))
                            <br/>print("i like to play {}".format(sports[1]))
                            <br/>print("i like to play {}".format(sports[2]))
                            <br/>print("i like to play {}".format(sports[3]))
                            <br/>
                            <br/># 2
                            <br/>names = ['John', 'Abraham', 'Sam', 'Kelly']
                            <br/>print(names[0][0], names[1][0], names[2][0], names[3][0])
                            <br/>
                            <br/># lists complete imp part is copying a list and manipulating items
                            <br/># writing your first for loop using range
                            <br/>for num in range(5):
                            <br/><span class="tab"></span>print("Value: {}".format(num))
                            <br/>
                            <br/># providing the start, stop, and step for the range function
                            <br/>for num in range(2, 10, 2): # 10 not included : its up to 10
                            <br/><span class="tab"></span>print("Value: {}".format(num)) <span class="tab"></span> # will print all evens between 2 and 10
                            <br/>
                            <br/># printing all characters in a name using the 'in' keyword
                            <br/>name = "John Smith"
                            <br/>for letter in name:
                            <br/><span class="tab"></span>print("Value: {}".format(letter))
                            <br/>
                            <br/># Continue statement
                            <br/>for num in range(5):
                            <br/><span class="tab"></span>if num == 3:
                            <br/><span class="tab"></span><span class="tab"></span>continue <span class="tab"></span> # using the continue statement within a for loop
                            <br/><span class="tab"></span><span class="tab"></span>print(num)
                            <br/>
                            <br/>
                            <br/># Break statement: only break from loop which has break
                            <br/>for num in range(5):
                            <br/><span class="tab"></span>if num == 3:
                            <br/><span class="tab"></span><span class="tab"></span>break <span class="tab"></span> # breaking out of a loop using the 'break' keyword
                            <br/><span class="tab"></span><span class="tab"></span>print(num)
                            <br/>
                            <br/>
                            <br/># Pass Statement
                            <br/>
                            <br/># setting a placeholder using the 'pass' keyword
                            <br/>for i in range(5):
                            <br/><span class="tab"></span># TODO: add a code to print number
                            <br/><span class="tab"></span>pass
                            <br/>
                            <br/>'''
                            <br/>If you take the pass statement out completely,the program will
                            <br/>break because there needs to be some sort of code within the block.
                            <br/>'''
                            <br/>
                            <br/># TUESDAY EXERCISE<br/>
                            <br/># 1: divisible by 3
                            <br/>print("Numbers divisible by 3 till 100\n")
                            <br/>for num in range(1, 101, 1):
                            <br/><span class="tab"></span>if num % 3 == 0:
                            <br/><span class="tab"></span><span class="tab"></span>print("{}".format(num))
                            <br/>
                            <br/>print("\nFinding vowels in user input\n")
                            <br/>inp = input("Enter a Sentence:\n")
                            <br/>Sto = (len(inp))
                            <br/>for i in range(0, Sto, 1):
                            <br/><span class="tab"></span>if inp[i] == 'a' or inp[i] == 'A':
                            <br/><span class="tab"></span><span class="tab"></span>print(inp[i])
                            <br/><span class="tab"></span>if inp[i] == 'e' or inp[i] == 'E':
                            <br/><span class="tab"></span><span class="tab"></span>print(inp[i])
                            <br/><span class="tab"></span>if inp[i] == 'i' or inp[i] == 'I':
                            <br/><span class="tab"></span><span class="tab"></span>print(inp[i])
                            <br/><span class="tab"></span>if inp[i] == 'o' or inp[i] == 'O':
                            <br/><span class="tab"></span><span class="tab"></span>print(inp[i])
                            <br/><span class="tab"></span>if inp[i] == 'u' or inp[i] == 'U':
                            <br/><span class="tab"></span><span class="tab"></span>print(inp[i])
                            <br/>
                            <br/>
                            <br/># Wednesday: While loops
                            <br/>
                            <br/># writing while loops
                            <br/>
                            <br/>health = 10
                            <br/>while health > 0:
                            <br/><span class="tab"></span>print(health)
                            <br/><span class="tab"></span>health -= 1 # forgetting this line result in infinite loop
                            <br/>
                            <br/># While Vs For
                            <br/># general rule of thumb is counting with for loops, conditions with while loops.
                            <br/>
                            <br/>
                            <br/># game_over = False
                            <br/># while not game_over:
                            <br/># <span class="tab"></span>print(game_over) <span class="tab"></span> # A infinite loop
                            <br/>
                            <br/># Nested Loops
                            <br/># using two or more loops is called a nested loop
                            <br/>
                            <br/>for i in range(2): <span class="tab"></span> # outside loop
                            <br/><span class="tab"></span>for j in range(3): <span class="tab"></span> # inside loop
                            <br/><span class="tab"></span><span class="tab"></span>print(i, j)
                            <br/>
                            <br/># Wednesday exercise
                            <br/>
                            <br/># userIP = 1
                            <br/># while userIP != 'quit':
                            <br/># <span class="tab"></span> userIP = input("Please enter the input:\n")
                            <br/>
                            <br/>game_over = 0
                            <br/>while not game_over:
                            <br/><span class="tab"></span>for k in range(0, 5, 1):
                            <br/><span class="tab"></span><span class="tab"></span>if k == 3:
                            <br/><span class="tab"></span><span class="tab"><span class="tab"></span></span>game_over = True
                            <br/><span class="tab"></span><span class="tab"></span><span class="tab"></span>break
                            <br/><span class="tab"></span><span class="tab"></span>else:
                            <br/><span class="tab"></span><span class="tab"></span><span class="tab"></span>print(k)
                            <br/>
                            <br/>
                            <br/># Working with lists
                            <br/>
                            <br/># checking length
                            <br/>nums = [5, 10, 15]
                            <br/>length = len(nums) <span class="tab"></span> # len() returns length
                            <br/>print(length)
                            <br/>
                            <br/># Slicing list
                            <br/>
                            <br/># accessing specific items of a lost with slices
                            <br/>print(nums[1:3]) <span class="tab"></span># will output items in index 1 and 2
                            <br/>print(nums[:2])<span class="tab"></span> # will output items in index 0 and 2
                            <br/>print(nums[::2]) <span class="tab"></span># will print every other index - 0,2,4 etc
                            <br/>print(nums[-2:]) <span class="tab"></span># will output the last two items in the list
                            <br/>
                            <br/># adding items to a list by .append()
                            <br/>nums = [10, 20]
                            <br/>nums.append(5)
                            <br/>print(nums)
                            <br/>
                            <br/># insert a value i the list by .list()
                            <br/>words = ["ball", "base"]
                            <br/>words.insert(0, "glove") <span class="tab"></span> # 1st value is index second is value
                            <br/>print(words)
                            <br/>
                            <br/># Removing items by pop()
                            <br/># using pop to remove items and saving to a variable to use later
                            <br/>
                            <br/>items = [5, "ball", True]
                            <br/>items.pop() <span class="tab"></span># removes last item
                            <br/>removed_item = items.pop(0) <span class="tab"></span> # removes 5 and stores it into variable
                            <br/>print(removed_item, "\n", items) <span class="tab"></span> # only ball left in list now
                            <br/>
                            <br/># .remove() function removes based on list value
                            <br/>sports = ["baseball", "soccer", "football", "hockey"]
                            <br/>try:
                            <br/><span class="tab"></span>sports.remove("soccer")
                            <br/>except:
                            <br/><span class="tab"></span>print("That item does not exist in thr list")
                            <br/>print(sports)
                            <br/>
                            <br/># Now the reason why we use a try and
                            <br/># except with the removal is because if soccer didn't exist in the list, then the program
                            <br/># would crash
                            <br/>
                            <br/># using min, max, and sum
                            <br/>
                            <br/>nums = [5, 3, 9]
                            <br/>print(min(nums)) <span class="tab"></span> # will find the lowest number in the list
                            <br/>print(max(nums)) <span class="tab"></span> # will find the highest number in the list
                            <br/>print(sum(nums)) <span class="tab"></span> # will add all numbers in the list and return the sum
                            <br/>
                            <br/># sorting a list
                            <br/># using .sorted()
                            <br/>
                            <br/>nums = [5, 8, 0, 2]
                            <br/>sorted_nums = sorted(nums)
                            <br/>print(nums, sorted_nums) # original list are left intact
                            <br/>
                            <br/># .sort() changer the original string
                            <br/>nums.sort()
                            <br/>print(nums)
                            <br/>
                            <br/>
                            <br/># Conditionals and lists
                            <br/># using "in" and "not in" words
                            <br/>names = ["Jack", "Robert", "Mary"]
                            <br/>if "Mary" in names:
                            <br/><span class="tab"></span>print("found")
                            <br/>if "Jimmy" not in names:
                            <br/><span class="tab"></span>print("not found")
                            <br/>
                            <br/># checking an empty list
                            <br/>nums = []
                            <br/>if not nums: <span class="tab"></span> # same as 'if nums == []'
                            <br/><span class="tab"></span>print("empty")
                            <br/>
                            <br/># To check for a list with items, you would write the following:
                            <br/># if nums:
                            <br/>
                            <br/># using for loops
                            <br/>sports = ["Baseball", "Hockey", "Football", "Basketball"]
                            <br/>for sport in sports:
                            <br/><span class="tab"></span>print(sport)
                            <br/>
                            <br/># Using while loops to remove a certain value
                            <br/>names = ["Bob", "Jack", "Rob", "Bob", "Robert"]
                            <br/>while "Bob" in names:
                            <br/><span class="tab"></span>names.remove("Bob") # remove all instances of bob
                            <br/>print(names)
                            <br/>
                            <br/># THURSDAY EXERCISE
                            <br/># 1 REMOVING DUPLICATES
                            <br/>dup = ["Bob", "Kenny", "Amanda", "Bob", "Kenny"]
                            <br/>j = len(dup) - 1
                            <br/>for i in range(0, j, 1):
                            <br/><span class="tab"></span>x = dup.count(dup[i])
                            <br/><span class="tab"></span><span class="tab"></span>if x > 1:
                            <br/><span class="tab"></span><span class="tab"></span><span class="tab"></span>dup.remove(dup[i])
                            <br/>print(dup)
                            <br/>
                            <br/># 2 user input
                            <br/>i = 0
                            <br/>msg = 0
                            <br/>li1 = []
                            <br/>while msg!="quit":
                            <br/><span class="tab"></span>inp = input("Enter a word: ")
                            <br/><span class="tab"></span>if inp != "quit":
                            <br/><span class="tab"></span><span class="tab"></span>li1.append(inp)
                            <br/><span class="tab"></span>else:
                            <br/><span class="tab"></span><span class="tab"></span>msg = inp
                            <br/><span class="tab"></span>j = len(li1)
                            <br/><span class="tab"></span>print("The list is:")
                            <br/><span class="tab"></span>for i in range(0,j,1):
                            <br/><span class="tab"></span><span class="tab"></span>print(li1[i])
                            <br/>
                            <br/># Friday Project: Hangman
                            <br/>
                            <br/>import random
                            <br/>
                            <br/># library that we use in order to choose
                            <br/># on random words from a list of words
                            <br/>
                            <br/>name = input("What is your name? ")
                            <br/># Here the user is asked to enter the name first
                            <br/>
                            <br/>print("Good Luck ! ", name)
                            <br/>
                            <br/>words = ['rainbow', 'computer', 'science', 'programming', 'python', 'mathematics', 'player', 'condition', 'reverse', 'water', 'board', 'geeks']
                            <br/>
                            <br/># Function will choose one random
                            <br/># word from this list of words
                            <br/>word = random.choice(words)
                            <br/>
                            <br/>print("Guess the characters")
                            <br/>
                            <br/>guesses = ''
                            <br/>
                            <br/># any number of turns can be used here
                            <br/>turns = 12
                            <br/>
                            <br/>while turns > 0:
                            <br/>
                            <br/><span class="tab"></span># counts the number of times a user fails
                            <br/><span class="tab"></span>failed = 0
                            <br/>
                            <br/><span class="tab"></span># all characters from the input
                            <br/><span class="tab"></span># word taking one at a time.
                            <br/><span class="tab"></span>for char in word:
                            <br/>
                            <br/><span class="tab"></span># comparing that character with
                            <br/><span class="tab"></span># the character in guesses
                            <br/><span class="tab"></span><span class="tab"></span>if char in guesses:
                            <br/><span class="tab"></span><span class="tab"></span><span class="tab"></span>print(char)
                            <br/>
                            <br/><span class="tab"></span><span class="tab"></span>else:
                            <br/><span class="tab"></span><span class="tab"></span><span class="tab"></span>print("_")
                            <br/>
                            <br/><span class="tab"></span># for every failure 1 will be
                            <br/><span class="tab"></span># incremented in failure
                            <br/><span class="tab"></span>failed += 1
                            <br/>
                            <br/>if failed == 0:
                            <br/># user will win the game if failure is 0
                            <br/># and 'You Win' will be given as output
                            <br/><span class="tab"></span>print("You Win")
                            <br/>
                            <br/># this print the correct word
                            <br/><span class="tab"></span>print("The word is: ", word)
                            <br/><span class="tab"></span>break
                            <br/>
                            <br/># if user has input the wrong alphabet then
                            <br/># it will ask user to enter another alphabet
                            <br/>guess = input("guess a character:")
                            <br/>
                            <br/># every input character will be stored in guesses
                            <br/>guesses += guess
                            <br/>
                            <br/># check input with the character in word
                            <br/>if guess not in word:
                            <br/>
                            <br/><span class="tab"></span>turns -= 1
                            <br/>
                            <br/># if the character doesnt match the word
                            <br/># then Wrong will be given as output
                            <br/>print("Wrong")
                            <br/>
                            <br/># this will print the number of
                            <br/># turns left for the user
                            <br/>print("You have", + turns, 'more guesses')
                            <br/>
                            <br/>if turns == 0:
                            <br/><span class="tab"></span>print("You Loose")
                            <br/>
                            <br/># Weekly challenge week 4
                            <br/># 1 print a pyramid
                            <br/># Python 3.x code to demonstrate star pattern
                            <br/>
                            <br/># Function to demonstrate printing pattern triangle
                            <br/>def triangle(n):
                            <br/><span class="tab"></span># number of spaces
                            <br/><span class="tab"></span>k = n - 1
                            <br/>
                            <br/><span class="tab"></span># outer loop to handle number of rows
                            <br/><span class="tab"></span>for i in range(0, n):
                            <br/>
                            <br/><span class="tab"></span># inner loop to handle number spaces
                            <br/><span class="tab"></span># values changing acc. to requirement
                            <br/><span class="tab"></span>for j in range(0, k):
                            <br/><span class="tab"></span>print(end=" ")
                            <br/>
                            <br/><span class="tab"></span># decrementing k after each loop
                            <br/><span class="tab"></span>k = k - 1
                            <br/>
                            <br/><span class="tab"></span># inner loop to handle number of columns
                            <br/><span class="tab"></span># values changing acc. to outer loop
                            <br/><span class="tab"></span>for j in range(0, i + 1):
                            <br/><span class="tab"></span># printing stars
                            <br/><span class="tab"></span><span class="tab"></span>print("* ", end="")
                            <br/>
                            <br/><span class="tab"></span># ending line after each row
                            <br/><span class="tab"></span>print("\r")
                            <br/>
                            <br/>
                            <br/># Driver Code
                            <br/>n = 4
                            <br/>triangle(n)
                            <br/>
                            <br/># problem2
                            <br/># names = [ "John", " ", "Amanda", 5]
                            <br/>#for name in names:
                            <br/># <span class="tab"></span>if type(name) == str:
                            <br/># <span class="tab"></span><span class="tab"></span>if name.strip() != '':
                            <br/># <span class="tab"></span><span class="tab"></span><span class="tab"></span>print(name)
                            <br/>
                            <br/># Convert Celsius
                            <br/>
                            <br/>tem = [32, 12, 44, 29]
                            <br/>Ftem = []
                            <br/>l = len(tem)
                            <br/>print('\n')
                            <br/>for i in range(l):
                            <br/><span class="tab"></span>F = float(tem[i])*(9.0/5.0) + 32
                            <br/><span class="tab"></span><span class="tab"></span>Ftem.append(F)
                            <br/>
                            <br/>print(Ftem)


                        </p>
                    </section>

                    <section id="week5" class="main-section">
                        <header>
                            <h2>Week 5</h2>
                        </header>
                        <p class="support-text">
                            <br/># Creating and calling functions
                            <br/>
                            <br/># Monday
                            <br/>
                            <br/># A function is a block of code which only runs when it is called
                            <br/># You can pass data, known as parameters, into a function
                            <br/># A function can return data as a result
                            <br/>
                            <br/># def FunctionName(parameter):
                            <br/>
                            <br/>def printInfo(): # defines a function
                            <br/><span class="tab"></span>print("Name: John Smith")
                            <br/><span class="tab"></span>print("Age: 45")
                            <br/>
                            <br/>
                            <br/>printInfo()
                            <br/>printInfo()
                            <br/>
                            <br/>
                            <br/># performing a calculation in a function
                            <br/>def calc():
                            <br/><span class="tab"></span>x, y = 5, 10
                            <br/><span class="tab"></span>print(x + y)
                            <br/>
                            <br/>
                            <br/>calc()
                            <br/>
                            <br/>
                            <br/>def myName():
                            <br/><span class="tab"></span>print("Hitesh Kumar")
                            <br/>
                            <br/>
                            <br/>myName()
                            <br/>
                            <br/>
                            <br/>def pizzaToppings():
                            <br/><span class="tab"></span>print("Tomato")
                            <br/><span class="tab"></span>print("mushroom")
                            <br/><span class="tab"></span>print("onion")
                            <br/><span class="tab"></span>print("chicken")
                            <br/>
                            <br/>
                            <br/>pizzaToppings()
                            <br/>
                            <br/>
                            <br/># Tuesday
                            <br/>
                            <br/>def printName(name):
                            <br/><span class="tab"></span>print('Hello {}'.format(name))
                            <br/>
                            <br/>
                            <br/>printName('John')
                            <br/>
                            <br/>
                            <br/># passing a single parameter into a function
                            <br/>def printName(full_name):
                            <br/><span class="tab"></span>print("Your name is: {}".format(full_name))
                            <br/>
                            <br/>
                            <br/>printName("John Smith")
                            <br/>printName("Amanda")
                            <br/>
                            <br/>
                            <br/># passing multiple parameters into a function
                            <br/>def addNums(num1, num2):
                            <br/><span class="tab"></span>result = num1 + num2
                            <br/><span class="tab"></span>print("{} + {} = {}".format(num1, num2, result))
                            <br/>
                            <br/>
                            <br/>addNums(5, 8) <span class="tab"></span># will output 13
                            <br/>addNums(3.5, 5.5) <span class="tab"></span># will output 9.0
                            <br/>
                            <br/># using a function to square all information
                            <br/>numbers1 = [2, 4, 5, 10]
                            <br/>numbers2 = [1, 3, 6]
                            <br/>
                            <br/>
                            <br/>def squares(nums):
                            <br/><span class="tab"></span>for num in nums:
                            <br/><span class="tab"></span>print(num ** 2)
                            <br/>
                            <br/>
                            <br/>squares(numbers1)
                            <br/>squares(numbers2)
                            <br/>
                            <br/>
                            <br/># setting default parameter values
                            <br/>def calcArea(r, pi=3.14):
                            <br/><span class="tab"></span>area = pi * (r ** 2)
                            <br/><span class="tab"></span>print("Area: {}".format(area))
                            <br/>
                            <br/>
                            <br/>calcArea(2) <span class="tab"></span> # assuming radius is the value of 2
                            <br/>
                            <br/>
                            <br/># setting default parameter values
                            <br/>def printName(first, last, middle=""):
                            <br/><span class="tab"></span>if middle:
                            <br/><span class="tab"></span><span class="tab"></span>print("{} {} {}".format(first, middle, last))
                            <br/><span class="tab"></span>else:
                            <br/><span class="tab"></span><span class="tab"></span>print("{} {}".format(first, last))
                            <br/>
                            <br/>
                            <br/>printName("John", "Smith")
                            <br/>printName("John", "Smith", "Paul") <span class="tab"></span># will output with middle name
                            <br/>
                            <br/>
                            <br/># explicitly assigning values to parameters by referencing the name
                            <br/>def addNums(num1, num2):
                            <br/><span class="tab"></span>print(num2)
                            <br/><span class="tab"></span>print(num1)
                            <br/>
                            <br/>
                            <br/>addNums(5, num2=2.5)
                            <br/>
                            <br/>
                            <br/># using args parameter to take in a tuple of arbitrary values
                            <br/>def outputData(name, *args):
                            <br/><span class="tab"></span>print(type(args))
                            <br/><span class="tab"></span>for arg in args:
                            <br/><span class="tab"></span><span class="tab"></span>print(arg)
                            <br/>
                            <br/>
                            <br/>outputData("John Smith", 5, True, "Jess")
                            <br/>
                            <br/>
                            <br/># using kwargs parameter to take in a dictionary of arbitrary values
                            <br/>def outputData(**kwargs):
                            <br/><span class="tab"></span>print(type(kwargs))
                            <br/><span class="tab"></span>print(kwargs["name"])
                            <br/><span class="tab"></span>print(kwargs["num"])
                            <br/><span class="tab"></span>print(kwargs["b"])
                            <br/>
                            <br/>
                            <br/>outputData(name="John Smith", num=5, b=True)
                            <br/>
                            <br/># Tuesday exercise
                            <br/>
                            <br/>w = input("Enter a word: ")
                            <br/>print(w[0])
                            <br/>
                            <br/>
                            <br/>def CheckUpper(i):
                            <br/><span class="tab"></span>if i[0] == i[0].upper():
                            <br/><span class="tab"></span><span class="tab"></span>print("True")
                            <br/><span class="tab"></span>else:
                            <br/><span class="tab"></span><span class="tab"></span>print("false")
                            <br/>
                            <br/>
                            <br/>CheckUpper(w)
                            <br/>
                            <br/>
                            <br/># Question 2
                            <br/>
                            <br/>def NoName(first_name="",last_name=""):
                            <br/><span class="tab"></span>if first_name or last_name:
                            <br/><span class="tab"></span><span class="tab"></span>print(first_name,last_name)
                            <br/><span class="tab"></span>else:
                            <br/><span class="tab"></span><span class="tab"></span>print("No name passed in")
                            <br/>
                            <br/>NoName("Hitesh","Kumar")
                            <br/>NoName()
                            <br/>
                            <br/># Wednesday: RETURN STATEMENT
                            <br/>
                            <br/>def returnMultiple():
                            <br/><span class="tab"></span>a = 5
                            <br/><span class="tab"></span>b = 10
                            <br/><span class="tab"></span>return [a, b]
                            <br/>
                            <br/>
                            <br/># using return keyword to return the sum of two numbers
                            <br/>def addNums(num1, num2):
                            <br/><span class="tab"></span>return num1 + num2
                            <br/>
                            <br/>
                            <br/>num = addNums(5.5, 4.5) <span class="tab"></span> # saves returned value into num
                            <br/>print(num)
                            <br/>print(addNums(10, 10)) <span class="tab"></span># doesn't save returned value
                            <br/>
                            <br/>
                            <br/># shorthand syntax using a ternary operator
                            <br/>def searchList(aList, el):
                            <br/><span class="tab"></span>return True if el in aList else False
                            <br/>
                            <br/>
                            <br/>result = searchList(["one", 2, "three"], 2) <span class="tab"></span> # result = True
                            <br/>print(result)
                            <br/>
                            <br/>
                            <br/># Wednesday exercise
                            <br/># 1 full name
                            <br/>
                            <br/>def FullName(fname, lname):
                            <br/><span class="tab"></span>return fname + ' ' + lname
                            <br/>
                            <br/>
                            <br/>name = FullName('hitesh', 'kumar')
                            <br/>print(name)
                            <br/>
                            <br/>
                            <br/># 2 user input
                            <br/>def userInput():
                            <br/><span class="tab"></span>value = input("enter a value: ")
                            <br/><span class="tab"></span>return int(value)
                            <br/>
                            <br/>
                            <br/>z = userInput() + 23
                            <br/>print(z)
                            <br/>
                            <br/>
                            <br/># where global variables can be accessed
                            <br/>number = 5
                            <br/>
                            <br/>
                            <br/># def scopeTest():
                            <br/># <span class="tab"></span>number += 1 # not accessible due to function level scope
                            <br/>
                            <br/>
                            <br/># scopeTest()
                            <br/>
                            <br/># accessing variables defined in a function
                            <br/>def scopeTest():
                            <br/><span class="tab"></span>word = "function"
                            <br/><span class="tab"></span>return word
                            <br/>
                            <br/>
                            <br/>value = scopeTest()
                            <br/>print(value)
                            <br/>
                            <br/># changing list item values by index
                            <br/>sports = ["baseball", "football", "hockey", "basketball"]
                            <br/>
                            <br/>
                            <br/>def change(aList):
                            <br/><span class="tab"></span>aList[0] = "soccer"
                            <br/>
                            <br/>
                            <br/>print("Before Altering: {}".format(sports))
                            <br/>change(sports)
                            <br/>print("After Altering: {}".format(sports))
                            <br/>
                            <br/>
                            <br/># Thursday Exercise
                            <br/>
                            <br/>names = ['Bob', 'Rich', 'Amanda']
                            <br/>def changeValue(aList, name, index):
                            <br/><span class="tab"></span>aList[index] = name
                            <br/><span class="tab"></span>return aList
                            <br/>
                            <br/>print(changeValue(names,'Bill', 1))
                            <br/>print(changeValue(names,'Hitesh', 2))
                            <br/>
                            <br/># creating a shopping cart
                            <br/>from IPython.display import clear_output
                            <br/>
                            <br/>cart = []
                            <br/>
                            <br/>
                            <br/># create function to add items in cart
                            <br/>def addItem(item):
                            <br/><span class="tab"></span>clear_output()
                            <br/><span class="tab"></span>cart.append(item)
                            <br/><span class="tab"></span>print("{} has been added.".format(item))
                            <br/>
                            <br/>
                            <br/># removing items
                            <br/>def removeItems(item):
                            <br/><span class="tab"></span>clear_output()
                            <br/><span class="tab"></span>try:
                            <br/><span class="tab"></span><span class="tab"></span>cart.remove(item)
                            <br/><span class="tab"></span><span class="tab"></span>print("{} has been removed.".format(item))
                            <br/><span class="tab"></span>except:
                            <br/><span class="tab"></span><span class="tab"></span>print("sorry we couldn't remove that item.")
                            <br/>
                            <br/>
                            <br/># showing the cart
                            <br/>def showCart():
                            <br/><span class="tab"></span>clear_output()
                            <br/><span class="tab"></span>if cart:
                            <br/><span class="tab"></span><span class="tab"></span>print("here is your cart")
                            <br/><span class="tab"></span>for item in cart:
                            <br/><span class="tab"></span><span class="tab"></span>print("- {}".format(item))
                            <br/><span class="tab"></span>else:
                            <br/><span class="tab"></span><span class="tab"></span>print("your cart is empty")
                            <br/>
                            <br/>
                            <br/># clearing the cart
                            <br/>def clearCart():
                            <br/><span class="tab"></span>clear_output()
                            <br/><span class="tab"></span>cart.clear()
                            <br/><span class="tab"></span>print("your cart is empty")
                            <br/>
                            <br/>
                            <br/># creating main loop
                            <br/>def main():
                            <br/><span class="tab"></span>done = False
                            <br/><span class="tab"></span>while not done:
                            <br/><span class="tab"></span><span class="tab"></span>ans = input("quit/add/remove/show/clear: ").lower()
                            <br/><span class="tab"></span><span class="tab"></span>if ans == "quit":
                            <br/><span class="tab"></span><span class="tab"></span><span class="tab"></span>print("Thanks for using our program.")
                            <br/><span class="tab"></span><span class="tab"></span><span class="tab"></span>showCart()
                            <br/><span class="tab"></span><span class="tab"></span><span class="tab"></span>done = True
                            <br/>
                            <br/><span class="tab"></span><span class="tab"></span># handling user input
                            <br/><span class="tab"></span><span class="tab"></span>elif ans == "add":
                            <br/><span class="tab"></span><span class="tab"></span><span class="tab"></span>item = input("what would yiu like to add? ").title()
                            <br/><span class="tab"></span><span class="tab"></span><span class="tab"></span>addItem(item)
                            <br/><span class="tab"></span><span class="tab"></span>elif ans == "remove":
                            <br/><span class="tab"></span><span class="tab"></span><span class="tab"></span>item = input("What item would you like to remove? ").title()
                            <br/><span class="tab"></span><span class="tab"></span><span class="tab"></span>removeItems(item)
                            <br/><span class="tab"></span><span class="tab"></span>elif ans == "show":
                            <br/><span class="tab"></span><span class="tab"></span><span class="tab"></span>showCart()
                            <br/><span class="tab"></span><span class="tab"></span>elif ans == "clear":
                            <br/><span class="tab"></span><span class="tab"></span><span class="tab"></span>clearCart()
                            <br/><span class="tab"></span><span class="tab"></span>else:
                            <br/><span class="tab"></span><span class="tab"></span><span class="tab"></span>print("Sorry that was not an option.")
                            <br/>
                            <br/>
                            <br/>main() <span class="tab"></span># run the program
                            <br/>
                            <br/>
                        </p>
                    </section>
                    <section id="week6" class="main-section">
                        <header>
                            <h2>Week 6</h2>
                        </header>
                        <p class="support-text">
                            <br /># monday dictionaries
                            <br />
                            <br /># A dictionary is a collection of unordered data, which is stored in key-value pairs.
                            <br />
                            <br /># declaring a dictionary variable
                            <br />empty = {} <span class="tab"></span># empty dictionary
                            <br />person = {"name": "John Smith"} <span class="tab"></span># dictionary with one key/value pairs
                            <br />
                            <br />customer = {
                            <br /><span class="tab"></span>"name": "Morty",
                            <br /><span class="tab"></span>"age": "26"
                            <br />} <span class="tab"></span><span class="tab"></span><span class="tab"></span># dictionary with two key/value pairs
                            <br />print(customer)
                            <br />
                            <br /># You could also use dict( ) to declare an empty dictionary.
                            <br />
                            <br /># accessing dictionary information through keys
                            <br />person = {"name": "John"}
                            <br />print(person["name"]) <span class="tab"></span> # # access information through the key
                            <br />
                            <br /># using get method to access dictionary information
                            <br />person = {"name": "John"}
                            <br />print(person.get("name"))
                            <br />print(person.get("age", "Age is not available")) <span class="tab"></span># get is secure way to receive information
                            <br />
                            <br />
                            <br /># storing a list within a dictionary and accessing it
                            <br />data = {"sports": ["baseball", "football", "hockey", "soccer"]}
                            <br />print(data["sports"][0]) <span class="tab"></span># first access the key, then the index
                            <br />
                            <br /># Keep in mind that we cannot create a dictionary that stores a list without first
                            <br /># attaching a key:
                            <br />
                            <br /># improperly storing a list within a dictionary
                            <br />sports = ["baseball", "football", "hockey", "soccer"]
                            <br />sports_dict = dict({"sports": sports}) <span class="tab"></span> # will produce error, no key
                            <br />print(sports_dict)
                            <br />
                            <br />
                            <br /># storing a dictionary within a list and accessing it
                            <br />data = ["John", "Dennis", {"name": "Kirsten"}]
                            <br />print(data[2]) <span class="tab"></span> # the dictionary is in index 2
                            <br />print(data[2]["name"]) <span class="tab"></span> # first access the index, then access the key
                            <br />
                            <br /># storing a dictionary within a dictionary and accessing it
                            <br />data = {
                            <br /><span class="tab"></span>"team": "Boston Red Sox",
                            <br /><span class="tab"></span>"wins": {"2018": 108, "2017": 93}
                            <br />}
                            <br />print(data["wins"]) <span class="tab"></span> # will output the dictionary within the wins key
                            <br />print(data["wins"]["2018"]) <span class="tab"></span> # first access the wins key, then the next key
                            <br />
                            <br />
                            <br /># Monday Exercises
                            <br /># 1
                            <br />name = input("Enter your name: ")
                            <br />age = input("Enter your age: ")
                            <br />
                            <br />data = {"name": name, "age": age}
                            <br />print(data)
                            <br />
                            <br /># 2
                            <br />pizza = {
                            <br /><span class="tab"></span>'ingredients': ['cheese', 'sausage', 'peppers']
                            <br />}
                            <br />
                            <br />for key, value in pizza.items():
                            <br /><span class="tab"></span>x = value
                            <br />
                            <br />for i in range(0, len(x)):
                            <br /><span class="tab"></span>print(x[i])
                            <br />
                            <br />
                            <br /># Tuesday working with dictionary
                            <br />
                            <br /># adding new key/value pairs to a dictionary
                            <br />
                            <br />car = {"year": 2018}
                            <br />car["color"] = "Blue"
                            <br />print("year:{}\t Color:{}".format(car["year"], car["color"]))
                            <br />
                            <br /># Changing information
                            <br />
                            <br /># updating a value for a key/value pair that already exist
                            <br />
                            <br />car = {"year": 2018, "color": "Blue"}
                            <br />car["color"] = "Red"
                            <br />
                            <br />print("Year:{} \t Color:{}".format(car["year"], car["color"]))
                            <br />
                            <br /># Deleting information
                            <br />
                            <br /># deleting a key /value pair from a dictionary
                            <br />
                            <br />car = {"year": 2018}
                            <br />try:
                            <br /><span class="tab"></span>del car["year"]
                            <br /><span class="tab"></span>print(car)
                            <br />
                            <br />except:
                            <br /><span class="tab"></span>print("that key does not exist")
                            <br />
                            <br /># Looping a dictionary
                            <br />
                            <br /># Dictionaries are iterable like lists. However, they have three different methods for doing
                            <br /># so. You can iterate over both the keys and values together, only keys, or only values.
                            <br />
                            <br /># 1 looping over a dictionary via keys
                            <br />
                            <br />person = {"name": "John", "age": 26}
                            <br />for key in person.keys():
                            <br /><span class="tab"></span>print(key, " ", person[key]) <span class="tab"></span> # will output the value at the current key
                            <br />
                            <br />
                            <br /># 2 looping over a dictionary via the values
                            <br />person = {"name": "John", "age": 26}
                            <br />for value in person.values():
                            <br /><span class="tab"></span>print(value)
                            <br />
                            <br /># 3 looping over a dictionary via the key/value pair
                            <br />person = {"name": "John", "age": 26}
                            <br />for key, value in person.items():
                            <br /><span class="tab"></span>print("{}: {}".format(key, value))
                            <br />
                            <br />
                            <br /># Tuesday Exercises
                            <br /># 1
                            <br />
                            <br />epty = {}
                            <br />uname = input("please enter your name: ")
                            <br />uaddress = input("please enter your address: ")
                            <br />unumber = input("please enter your number: ")
                            <br />
                            <br />epty["name"] = uname
                            <br />epty["address"] = uaddress
                            <br />epty["number"] = unumber
                            <br />
                            <br />for key,value in epty.items():
                            <br /><span class="tab"></span>print("{} : {}".format(key,value))
                            <br />
                            <br /># challenge complete
                            <br />
                            <br /># 2
                            <br /># What is wrong with the following code:
                            <br />person = {'name', 'John Smith'} <span class="tab"></span> # : sign should be there between key and value
                            <br />print(person['name'])
                            <br />
                            <br />
                            <br /># Tuples sets and frozen sets
                            <br />
                            <br /># A tuple is identical to a list, except it is immutable. When something is immutable, it
                            <br /># means that it cannot be altered once declared. Tuples are useful for storing information
                            <br /># that you dont want to change. Theyre ordered like lists, so you can iterate through them
                            <br /># using an index.
                            <br />
                            <br /># declaring a tuple
                            <br />
                            <br />t1 = ("hello", 2, "hello") <span class="tab"></span> # with parens
                            <br />t2 = True, 1 # without parens
                            <br />print(type(t1), type(t2)) <span class="tab"></span># both are tuples
                            <br /># t1[0] = 1 <span class="tab"></span> # will crash, tuples are immutable once declared
                            <br />
                            <br /># The only way to overwrite the data within a tuple is to re-declare the
                            <br /># entire tuple.
                            <br />
                            <br />
                            <br /># Sets share the same characteristics of lists and dictionaries. A set is a collection of
                            <br /># information like a list; however, like a key in a dictionary, sets can only contain unique
                            <br /># values. They are also an unordered collection. This means that they cannot be accessed
                            <br /># by index but rather by the value itself like dictionary keys
                            <br />
                            <br />
                            <br /># Declaring a set
                            <br />
                            <br />s1 = set([1, 2, 3, 1]) <span class="tab"></span> # uses the set keyword and square brackets
                            <br />s2 = {4, 4, 5} <span class="tab"></span> # uses curly brackets, like dictionary
                            <br />print(type(s1), type(s2))
                            <br />
                            <br />
                            <br />s1.add(5) <span class="tab"></span># using the add method to add new items to a set
                            <br />s1.remove(1) <span class="tab"></span># using the remove method to get rid of the value 1
                            <br />print(s1) <span class="tab"></span># notice when printed it removed the second "1" at the end
                            <br />print(s2)
                            <br />
                            <br />
                            <br /># Frozenset are essentially the combination of a set and a tuple. They are immutable,
                            <br /># unordered, and unique. These are perfect for sensitive information like bank account
                            <br /># numbers, as you wouldn't want to alter those.
                            <br />
                            <br /># declaring a frozenset
                            <br />
                            <br />fset = frozenset([1, 2, 3, 4])
                            <br />print(type(fset))
                            <br />
                            <br /># Wednesday exercise
                            <br /># 1
                            <br />
                            <br />accountNo = []
                            <br />steps = 0
                            <br />acNo = 0
                            <br />while acNo != "Done":
                            <br /><span class="tab"></span>acNo = input("Enter Account Number/Done: ").title()
                            <br /><span class="tab"></span>if acNo == "Done":
                            <br /><span class="tab"></span><span class="tab"></span>break
                            <br /><span class="tab"></span>else:
                            <br /><span class="tab"></span><span class="tab"></span>accountNo.append(acNo)
                            <br />
                            <br />FrzAccounts = frozenset(accountNo)
                            <br />print(FrzAccounts)
                            <br />
                            <br />
                            <br /># 2
                            <br />
                            <br />nums = [3, 4, 3, 7, 10]
                            <br />z = frozenset(nums)
                            <br />print(z)
                            <br />
                            <br />
                            <br />nums = [3, 4, 3, 7, 10]
                            <br />step = 0
                            <br />for i in range(0, len(nums)-1):
                            <br /><span class="tab"></span>if nums[step] == nums[i]:
                            <br /><span class="tab"></span><span class="tab"></span>nums.pop(i)
                            <br /><span class="tab"></span>else:
                            <br /><span class="tab"></span><span class="tab"></span>step = 0
                            <br />print(nums)
                            <br />
                            <br />
                            <br /># Reading and writing files
                            <br />
                            <br /># Python comes with an open() function that allows us to create or modify
                            <br /># files. This function accepts two parameters, the file name, and the mode. If the file name
                            <br /># exists, then it will simply open the file for modification; otherwise, it will create the file
                            <br /># for you. The mode is in reference to how Python opens and works with the file.
                            <br />
                            <br /># opening/creating and writing to a text file
                            <br />
                            <br />f = open("test.txt", 'w+') # open file in writing and reading mode
                            <br />f.write('Hii this is how we write in a file')
                            <br />f.close()
                            <br />
                            <br /># reading from a text file
                            <br />
                            <br />f = open("test.txt", "r")
                            <br />data = f.read()
                            <br />f.close()
                            <br />print(data)
                            <br />
                            <br /># CSV files work with data by separating a comma between each cell. This is known as a
                            <br /># tabular data structure. To get started working with them, Python has a default library
                            <br /># called csv.
                            <br />
                            <br />import csv
                            <br />
                            <br />with open("test.csv", mode='w', newline="") as f:
                            <br /># the second method of opening files using the with keyword. This
                            <br /># concept works like a while loop, so that while the file is open, we can work with it, and
                            <br /># once the block of code is done running, it closes the file automatically for us.
                            <br />
                            <br />writer = csv.writer(f, delimiter=",")
                            <br />writer.writerow(["Name", "City"])
                            <br />writer.writerow(["Craig Lou", "Taiwan"])
                            <br />
                            <br /># reading from csv files
                            <br />
                            <br />
                            <br />with open("test.csv", mode="r") as f:
                            <br /><span class="tab"></span>reader = csv.reader(f, delimiter=",")
                            <br /><span class="tab"></span>for row in reader:
                            <br /><span class="tab"></span><span class="tab"></span>print(row)
                            <br />
                            <br /># File modes in python
                            <br />
                            <br /># r This is the default mode. It opens the file for reading only.
                            <br /># w Opens file for writing. If file doesn't exist, it creates one.
                            <br /># x Creates a new file. If file exists, the operation fails.
                            <br /># a Open in append mode. If file doesn't exist, it creates one.
                            <br /># b Open in binary mode.
                            <br /># + Will open a file for reading and writing. Good for updating.
                            <br />
                            <br /># Thursday Exercise
                            <br />
                            <br />favNo = input("Enter your favourite number: ")
                            <br />fi = open("fav.txt", 'w+')
                            <br />fi.write(favNo)
                            <br />fi.close()
                            <br />
                            <br />fi = open("fav.txt", 'r')
                            <br />data = fi.read()
                            <br />fi.close()
                            <br />print(data)
                            <br />
                            <br /># 2 Dumping data
                            <br />
                            <br />dict_data = {
                            <br /><span class="tab"></span>'name': ['Dave', 'Dennis', 'Peter', 'Jess'],
                            <br /><span class="tab"></span>'language': ['Python', 'C', 'Java', 'Python']
                            <br />}
                            <br />
                            <br />R = len(dict_data['name'])
                            <br />print(R)
                            <br />
                            <br />import csv
                            <br />
                            <br />with open('data.csv', mode='w+', newline="") as file:
                            <br /><span class="tab"></span>fieldnames = ['name', 'language']
                            <br /><span class="tab"></span>writer = csv.DictWriter(file, fieldnames=fieldnames)
                            <br /><span class="tab"></span>writer.writeheader()
                            <br /><span class="tab"></span>for i in range(0, R):
                            <br /><span class="tab"></span><span class="tab"></span>writer.writerow({'name': dict_data['name'][i], 'language': dict_data['language'][i]})
                            <br />
                            <br />file = open("data.csv", 'r')
                            <br />data = file.read()
                            <br />file.close()
                            <br />print(data)
                            <br />
                            <br />
                            <br /># Friday PROJECT
                            <br />
                            <br /># Creating a database with CSV files
                            <br />
                            <br />import csv
                            <br />from IPython.display import clear_output
                            <br />
                            <br />
                            <br /># Handling user registration and writing it to csv
                            <br />
                            <br />def registerUser():
                            <br /><span class="tab"></span>with open("users.csv", mode='a', newline="") as f:
                            <br /><span class="tab"></span>writer = csv.writer(f, delimiter=",")
                            <br /><span class="tab"></span>print("To register, please enter your info: ")
                            <br /><span class="tab"></span>email = input("Enter E-mail: ")
                            <br /><span class="tab"></span>password = input("Enter Password: ")
                            <br /><span class="tab"></span>password2 = input("Re-type password: ")
                            <br /><span class="tab"></span>clear_output()
                            <br /><span class="tab"></span>if password == password2:
                            <br /><span class="tab"></span><span class="tab"></span>writer.writerow([email, password])
                            <br /><span class="tab"></span><span class="tab"></span>print("you are registered!")
                            <br /><span class="tab"></span>else:
                            <br /><span class="tab"></span><span class="tab"></span>print("something went wrong! try again.")
                            <br />
                            <br />
                            <br /># Handling user login
                            <br />
                            <br />def loginUser():
                            <br /><span class="tab"></span>print("To login, please enter your info: ")
                            <br /><span class="tab"></span>email = input("email: ")
                            <br /><span class="tab"></span>password = input("password")
                            <br /><span class="tab"></span>clear_output()
                            <br /><span class="tab"></span>with open("users.csv", mode='r') as f:
                            <br /><span class="tab"></span><span class="tab"></span>reader = csv.reader(f, delimiter=",")
                            <br /><span class="tab"></span><span class="tab"></span>for row in reader:
                            <br /><span class="tab"></span><span class="tab"></span><span class="tab"></span>if row == [email, password]:
                            <br /><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="tab"></span>print("you are logged in!")
                            <br /><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="tab"></span>return True
                            <br /><span class="tab"></span><span class="tab"></span><span class="tab"></span>else:
                            <br /><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="tab"></span>print("something went wrong! try again.")
                            <br /><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="tab"></span>return False
                            <br />
                            <br />
                            <br />
                            <br /># creating main loop
                            <br />
                            <br /># main variables
                            <br />active = True
                            <br />logged_in = False
                            <br />
                            <br /># main loop
                            <br />while active:
                            <br /><span class="tab"></span>if logged_in:
                            <br /><span class="tab"></span><span class="tab"></span>print("1. Logout\n2. Quit")
                            <br /><span class="tab"></span>else:
                            <br /><span class="tab"></span><span class="tab"></span>print("1. Login\n2. Register\n3. Quit")
                            <br /><span class="tab"></span>
                            <br /><span class="tab"></span>choice = input("What would you like to do?:\t").lower()
                            <br /><span class="tab"></span>clear_output()
                            <br /><span class="tab"></span>if choice == "register" and logged_in== False:
                            <br /><span class="tab"></span><span class="tab"></span>registerUser()
                            <br /><span class="tab"></span>elif choice == "login" and logged_in == False:
                            <br /><span class="tab"></span><span class="tab"></span>logged_in == loginUser()
                            <br /><span class="tab"></span><span class="tab"></span>logged_in = True
                            <br /><span class="tab"></span>elif choice == "quit":
                            <br /><span class="tab"></span><span class="tab"></span>active == False
                            <br /><span class="tab"></span><span class="tab"></span>print("Thanks for using our software!")
                            <br /><span class="tab"></span><span class="tab"></span>break
                            <br /><span class="tab"></span>elif choice == "logout" and logged_in == True:
                            <br /><span class="tab"></span><span class="tab"></span>logged_in = False
                            <br /><span class="tab"></span><span class="tab"></span>print("You are now logged out.")
                            <br /><span class="tab"></span>else:
                            <br /><span class="tab"></span><span class="tab"></span>print("Sorry, please try again!")
                            <br />
                            <br /># Palindrome Challenge
                            <br />
                            <br />word = "nitin"
                            <br />if word == word[::-1]:
                            <br /><span class="tab"></span>print("string is palindrome")
                            <br />else:
                            <br /><span class="tab"></span>print("not a palindrome")
                            <br />
                            <br /># Food challenge
                            <br />
                            <br />
                            <br />import csv
                            <br />
                            <br />i = 0
                            <br />while i != 2:
                            <br /><span class="tab"></span>Choice = int(input("1. Enter food and vote\n2. Done \nChoose between 1 and 2. "))
                            <br /><span class="tab"></span>if Choice == 1:
                            <br /><span class="tab"></span><span class="tab"></span>with open("food.csv", mode='w+', newline="") as f:
                            <br /><span class="tab"></span><span class="tab"></span>writer = csv.DictWriter(f, fieldnames=['Favourite Food?', '# of votes'])
                            <br /><span class="tab"></span><span class="tab"></span>writer.writeheader()
                            <br /><span class="tab"></span><span class="tab"></span>writer = csv.writer(f, delimiter=",")
                            <br /><span class="tab"></span><span class="tab"></span>Fav_Food = input("Enter the name of food: ")
                            <br /><span class="tab"></span><span class="tab"></span>Vote = input("Vote {} out of 5: ".format(Fav_Food))
                            <br /><span class="tab"></span><span class="tab"></span>writer.writerow([Fav_Food, Vote])
                            <br /><span class="tab"></span>
                            <br /><span class="tab"></span><span class="tab"></span>f = open("food.csv", 'r')
                            <br /><span class="tab"></span><span class="tab"></span>data = f.read()
                            <br /><span class="tab"></span><span class="tab"></span>f.close()
                            <br /><span class="tab"></span><span class="tab"></span>print(data)
                            <br /><span class="tab"></span>
                            <br /><span class="tab"></span>
                            <br /><span class="tab"></span>elif Choice == 2:
                            <br /><span class="tab"></span><span class="tab"></span>print("Thanks for using our Software")
                            <br /><span class="tab"></span><span class="tab"></span>break
                            <br /><span class="tab"></span>
                            <br /><span class="tab"></span>else:
                            <br /><span class="tab"></span><span class="tab"></span>print("That is not an option!!!")
                        </p>
                    </section>
                    <section id="week7" class="main-section">
                        <header>
                            <h2>Week 7</h2>
                        </header>
                        <p class="support-text">
                            <br/># WEEK 7 Object oriented Programming
                            <br/>
                            <br/>values = {4: 4, 8: 8, "Q": 10, "ACE": 11}
                            <br/>card = ("Q", "Hearts")
                            <br/>print("{}".format(values[card[0]]))
                            <br/>
                            <br/>
                            <br/># Monday: Creating and instantiating a class
                            <br/>
                            <br/># All objects in Python are created from classes. The point of OOP is to reuse the same
                            <br/># code while giving flexibility to create each object with their own features.
                            <br/>
                            <br/># OOP Stages
                            <br/>
                            <br/># There are two stages when using classes. The first stage is the class definition. Like
                            <br/># function definitions, this stage is where you write the blueprint to be used when called.
                            <br/># The second stage is called instantiation. It is the process of creating an object from the
                            <br/># class definition. After an object is instantiated, it is known as an instance.
                            <br/>
                            <br/># The first step in using classes is creating the class definition or blueprint. To create
                            <br/># a new class, the syntax is like functions, but you use the class keyword instead of def.
                            <br/>
                            <br/>
                            <br/># DEFINING FIRST CLASS
                            <br/>class Car:
                            <br/><span class="tab"></span>pass # simply using as a placeholder until we add more code tomorrow
                            <br/>
                            <br/>
                            <br/>ford = Car() <span class="tab"></span># Creating first instance
                            <br/>print(ford)
                            <br/>
                            <br/>subaru = Car() <span class="tab"></span># Creating multiple instances
                            <br/>print(hash(ford))
                            <br/>print(hash(subaru)) <span class="tab"></span># # hash outputs a numerical representation of the location in memory for the variable
                            <br/>
                            <br/>
                            <br/># Monday exercises
                            <br/>
                            <br/>class animals:
                            <br/><span class="tab"></span>pass
                            <br/>
                            <br/>
                            <br/>lion = animals()
                            <br/>tiger = animals()
                            <br/>
                            <br/>
                            <br/>class Bus:
                            <br/><span class="tab"></span>pass
                            <br/>
                            <br/>
                            <br/>school_bus = Bus()
                            <br/>
                            <br/>
                            <br/># Tuesday : ATTRIBUTES
                            <br/>
                            <br/># Today, well begin to understand
                            <br/># how to give personalized features, known as attributes, to classes and their instances.
                            <br/># Attributes are just variables defined within a class, nothing more than that
                            <br/>
                            <br/># how to define attributes
                            <br/>
                            <br/>class Car:
                            <br/><span class="tab"></span>sound = "beep"
                            <br/><span class="tab"></span>color = "red"
                            <br/>
                            <br/>
                            <br/>ford = Car()
                            <br/>print(ford.color) <span class="tab"></span> # known as 'dot syntax'
                            <br/>
                            <br/>
                            <br/># Changing the value of an attribute
                            <br/>class Car():
                            <br/>sound = "beep"
                            <br/>color = "red"
                            <br/>
                            <br/>
                            <br/>ford = Car()
                            <br/>print(ford.sound)
                            <br/>ford.sound = "honk"
                            <br/>
                            <br/>print(ford.sound)
                            <br/>
                            <br/>
                            <br/># USING the __init__() method
                            <br/>
                            <br/># When you want to instantiate
                            <br/># an object with specific properties, you need to use the initialization (init) method.
                            <br/># Whenever an instance is created, the init method is called immediately.
                            <br/>
                            <br/>
                            <br/># using the init method to give instances personalized attributes upon creation
                            <br/>
                            <br/>class Car:
                            <br/><span class="tab"></span>def __init__(self, color):
                            <br/><span class="tab"></span>self.color = color # sets the attribute color to the value passed in
                            <br/>
                            <br/>
                            <br/>ford = Car("blue") <span class="tab"></span># instantiating a Car class with the color blue
                            <br/>print(ford.color)
                            <br/>
                            <br/>
                            <br/># The self keyword
                            <br/>
                            <br/># The self keyword is a reference to the current instance of the class and is used to access
                            <br/># variables and methods associated with that instance.
                            <br/>
                            <br/># Instantiating Multiple Objects with __init__()
                            <br/>
                            <br/># defining different values for multiple instances
                            <br/>
                            <br/>class Car:
                            <br/><span class="tab"></span>def __init__(self, color, year):
                            <br/><span class="tab"></span>self.color = color
                            <br/><span class="tab"></span>self.year = year
                            <br/>
                            <br/>
                            <br/>ford = Car("Blue", 2016)
                            <br/>subaru = Car("red", 2018)
                            <br/>
                            <br/>print(ford.color, ford.year)
                            <br/>print(subaru.color, subaru.year)
                            <br/>
                            <br/>
                            <br/># Global attributes vs. Instance attributes
                            <br/>
                            <br/># Global attributes can be referenced by the class directly and all
                            <br/># its instances, whereas instance attributes (which are defined within the init method)
                            <br/># can only be accessed by the class instances. If an attribute is declared inside of a class,
                            <br/># but not within the init method, then it is known as a global attribute. Any attributes
                            <br/># declared within the init method using the self keyword are instance attributes
                            <br/>
                            <br/>
                            <br/># using and accessing global class attributes
                            <br/>
                            <br/>class Car:
                            <br/><span class="tab"></span>sound = "Beep" <span class="tab"></span> # global attribute, accessible through the class itself
                            <br/>
                            <br/><span class="tab"></span>def __init__(self, color):
                            <br/><span class="tab"></span>self.color = "blue" <span class="tab"></span> # # instance specific attribute, not accessible through the class itself
                            <br/>
                            <br/>
                            <br/>print(Car.sound)
                            <br/># print(Car.color) <span class="tab"></span> won't work, as color is only available to
                            <br/># <span class="tab"></span>instances of the Car class, not the class itself
                            <br/>
                            <br/>ford = Car("Blue")
                            <br/>print(ford.sound, ford.color) <span class="tab"></span> # color will work as this is an instance
                            <br/>
                            <br/>
                            <br/># Tuesday Exercise
                            <br/>
                            <br/>class Dog:
                            <br/><span class="tab"></span>species = "Canine"
                            <br/>
                            <br/><span class="tab"></span>def __init__(self, name, breed):
                            <br/><span class="tab"></span>self.name = name
                            <br/><span class="tab"></span>self.breed = breed
                            <br/>
                            <br/>
                            <br/>dog1 = Dog("Sammi", "Husky")
                            <br/>dog2 = Dog("Casey", "Chocolate_Lab")
                            <br/>
                            <br/>print(dog1.name, dog1.breed)
                            <br/>print(dog2.name, dog2.breed)
                            <br/>
                            <br/>
                            <br/>class Person:
                            <br/><span class="tab"></span>def __init__(self, name):
                            <br/><span class="tab"></span>self.name = name
                            <br/>
                            <br/>
                            <br/>N = input("Enter your name: ")
                            <br/>P1 = Person(N)
                            <br/>print(P1.name)
                            <br/>
                            <br/>
                            <br/># Wednesday Methods
                            <br/># Methods are essentially functions that are within classes. If you hear someone talking
                            <br/># about methods, youll instantly know that they are talking about OOP
                            <br/>
                            <br/># defining and calling
                            <br/>
                            <br/>class Dog:
                            <br/><span class="tab"></span>def makeSound(self):
                            <br/><span class="tab"></span>print("bark")
                            <br/>
                            <br/>
                            <br/>sam = Dog()
                            <br/>sam.makeSound()
                            <br/>
                            <br/>
                            <br/># accessing class attributes within the class
                            <br/>
                            <br/>class Dog:
                            <br/><span class="tab"></span>sound = "Bark"
                            <br/>
                            <br/>def makeSound(self):
                            <br/><span class="tab"></span>print(self.sound) <span class="tab"></span> # # self required to access attributes defined in the class
                            <br/>
                            <br/>
                            <br/>sam = Dog()
                            <br/>sam.makeSound()
                            <br/>
                            <br/>
                            <br/># Method SCOPE
                            <br/>
                            <br/># Like global attributes, you may have methods that are accessible through the class itself
                            <br/># rather than an instance of the class. These may also be known as static methods. They
                            <br/># are not accessible by instances of the class.
                            <br/>
                            <br/># # understanding which methods are accessible via the class itself and
                            <br/># class instances
                            <br/>
                            <br/>class Dog():
                            <br/><span class="tab"></span>sound = "Bark"
                            <br/>
                            <br/><span class="tab"></span>def makeSound(self):
                            <br/><span class="tab"></span><span class="tab"></span>print(self.sound)
                            <br/>
                            <br/><span class="tab"></span>def printInfo():
                            <br/><span class="tab"></span><span class="tab"></span>print("I am dog")
                            <br/>
                            <br/>
                            <br/>Dog.printInfo() <span class="tab"></span> # # able to run printInfo method because it does not include self parameter
                            <br/>
                            <br/># Dog.makeSound() <span class="tab"></span> # Produce an error, self is in reference to instances only
                            <br/>
                            <br/>sam = Dog()
                            <br/>
                            <br/>sam.makeSound() <span class="tab"></span># able to access, self can reference the instance of sam
                            <br/>
                            <br/>
                            <br/># sam.printInfo() <span class="tab"></span> # will produce error, instances require the self parameter to access methods
                            <br/>
                            <br/>
                            <br/># Passing arguments into methods
                            <br/>
                            <br/># writing methods that accept parameters
                            <br/>
                            <br/>class Dog:
                            <br/><span class="tab"></span>def showAge(self, age):
                            <br/><span class="tab"></span><span class="tab"></span>print(age) <span class="tab"></span># # does not need self, age is referencing the parameter not an attribute
                            <br/>
                            <br/>
                            <br/>sam = Dog()
                            <br/>sam.showAge(6) <span class="tab"></span># passing the integer 6 as an argument to the showAge method
                            <br/>
                            <br/>
                            <br/># Using setters and getters
                            <br/>
                            <br/># They are methods that you
                            <br/># create to re-declare attribute values and return attribute values.
                            <br/>
                            <br/># using methods to set or return attribute values, proper programming practice
                            <br/>
                            <br/>class Dog:
                            <br/><span class="tab"></span>name = " " <span class="tab"></span> # would normally use init method to declare, this is for testing purposes
                            <br/>
                            <br/><span class="tab"></span>def setName(self, new_name):
                            <br/><span class="tab"></span>self.name = new_name <span class="tab"></span># declares the new value for the name attribute
                            <br/>
                            <br/><span class="tab"></span>def getName(self):
                            <br/><span class="tab"></span>return self.name <span class="tab"></span># returns the value of the name attribute
                            <br/>
                            <br/>
                            <br/>sam = Dog()
                            <br/>sam.setName("Sammi")
                            <br/>print(sam.getName()) <span class="tab"></span># prints the returned value of self.name
                            <br/>
                            <br/>
                            <br/># Incrementing Attributes with Methods
                            <br/>
                            <br/># Like setters, when you want to alter an attributes value by incrementing or decrementing
                            <br/># it rather than just changing it completely, the best way is to create a method to complete
                            <br/># the task:
                            <br/>
                            <br/>class Dog():
                            <br/><span class="tab"></span>age = 5
                            <br/>
                            <br/>def happyBirthday(self):
                            <br/><span class="tab"></span>self.age += 1
                            <br/>
                            <br/>
                            <br/>sam = Dog()
                            <br/>sam.happyBirthday() <span class="tab"></span># calls method to increment value by one
                            <br/>print(sam.age) <span class="tab"></span># better practice use getters, this is for testing
                            <br/>
                            <br/>
                            <br/># Methods calling methods
                            <br/># When calling a method from another method, you need to use the self parameter
                            <br/>
                            <br/># calling a class method from another method
                            <br/>class Dog:
                            <br/><span class="tab"></span>age = 6
                            <br/>
                            <br/><span class="tab"></span>def getAge(self):
                            <br/><span class="tab"></span><span class="tab"></span>return self.age
                            <br/>
                            <br/><span class="tab"></span>def printInfo(self):
                            <br/><span class="tab"></span><span class="tab"></span>if self.getAge()
                            < 10: <span class="tab">
                                </span> # need self to call other method for an instance
                                <br/><span class="tab"></span><span class="tab"></span><span class="tab"></span>print("Puppy!")
                                <br/>
                                <br/>
                                <br/>sam = Dog()
                                <br/>sam.printInfo()
                                <br/>
                                <br/>
                                <br/># Magic Methods
                                <br/>
                                <br/># All magic methods
                                <br/># have two underscores before and after their name. When you print out anything,
                                <br/># youre accessing a magic method called __str__. When you use operators (+, -, /, , ==,
                                <br/># etc.), youre accessing magic methods. They are essentially functions that decide what
                                <br/># operators and other tasks in Python perform.
                                <br/>
                                <br/>class Dog:
                                <br/><span class="tab"></span>def __str__(self):
                                <br/><span class="tab"></span><span class="tab"></span>return "This is a dog class"
                                <br/>
                                <br/>
                                <br/>sam = Dog()
                                <br/>print(sam) <span class="tab"></span> # will print the return of the string magic method
                                <br/>
                                <br/>
                                <br/>
                                <br/># 1. SETTER AND GETTER TO CHANGE ATTRIBUTE
                                <br/>
                                <br/>class animals:
                                <br/><span class="tab"></span>def __init__(self, species=0):
                                <br/><span class="tab"></span><span class="tab"></span>self.species = species
                                <br/>
                                <br/><span class="tab"></span># getter method
                                <br/>
                                <br/><span class="tab"></span>def Getter(self):
                                <br/><span class="tab"></span><span class="tab"></span>print(self.species)
                                <br/>
                                <br/><span class="tab"></span># setter method
                                <br/>
                                <br/><span class="tab"></span>def Setter(self, species):
                                <br/><span class="tab"></span><span class="tab"></span>self.species = species
                                <br/>
                                <br/>
                                <br/>Lion = animals()
                                <br/>Lion.Setter("Feline")
                                <br/>Lion.Getter()
                                <br/>
                                <br/># User input
                                <br/>
                                <br/>class person:
                                <br/><span class="tab"></span>def __init__(self,name, age= 0):
                                <br/><span class="tab"></span><span class="tab"></span>self.name = name
                                <br/>
                                <br/><span class="tab"></span>def Setter(self):
                                <br/><span class="tab"></span><span class="tab"></span>age = input("Please enter your age: ")
                                <br/><span class="tab"></span><span class="tab"></span>self.age = age
                                <br/>
                                <br/><span class="tab"></span>def Getter(self):
                                <br/><span class="tab"></span><span class="tab"></span>print("You are {} years old".format(self.age))
                                <br/>
                                <br/>p1 = person("hitesh")
                                <br/>p1.Setter()
                                <br/>p1.Getter()
                                <br/>
                                <br/># Thursday : INHERITANCE
                                <br/>
                                <br/># Sometimes youll create classes that will have similar attributes or methods. Take a Dog
                                <br/># and Cat class, for example. Both will have nearly the same code, attributes, and methods.
                                <br/># Rather than writing the same code twice, we use a concept called inheritance.
                                <br/>
                                <br/># Inheritance is one of the concepts that allow classes to have code re-usability within
                                <br/># programming. When you have two or more classes that use similar code, you generally
                                <br/># want to set up what is called a superclass. The two classes that will inherit all the code
                                <br/># within the superclass are known as subclasses.
                                <br/>
                                <br/># inheriting a class and accessing the inherited method
                                <br/>
                                <br/>class Animal:
                                <br/><span class="tab"></span>def makeSound(self):
                                <br/><span class="tab"></span><span class="tab"></span>print("roar")
                                <br/>
                                <br/>
                                <br/>class Dog(Animal): <span class="tab"></span> # Inheriting class animal
                                <br/><span class="tab"></span>species = "Canine"
                                <br/>
                                <br/>
                                <br/>sam = Dog()
                                <br/>sam.makeSound()
                                <br/>lion = Animal()
                                <br/>
                                <br/>
                                <br/># lion.species not accessible, because inheritance does not work backwards
                                <br/>
                                <br/>
                                <br/># Using the super() method to declare inherited attributes
                                <br/>
                                <br/># The super method is used to create forward compatibility when using inheritance. When
                                <br/># declaring attributes that are required within the superclass, super is used to initialize its
                                <br/># values.
                                <br/>
                                <br/>
                                <br/>class Animals:
                                <br/><span class="tab"></span>def __init__(self, species):
                                <br/><span class="tab"></span><span class="tab"></span>self.species = species
                                <br/>
                                <br/>
                                <br/>class Dog(Animals):
                                <br/><span class="tab"></span>def __init__(self, species, name):
                                <br/><span class="tab"></span><span class="tab"></span>self.name = name
                                <br/><span class="tab"></span>super().__init__(species) <span class="tab"></span># using super to declare the species attribute defined in Animal
                                <br/>
                                <br/>
                                <br/>sam = Dog("Canine", "Sammi")
                                <br/>print(sam.species)
                                <br/>
                                <br/>
                                <br/># Method Overriding
                                <br/>
                                <br/># Sometimes when using inheritance, you want the subclass to be able to perform a
                                <br/># different action when the same method is called. Take our makeSound method from the
                                <br/># previously created Animal class. It prints out roar, but thats not the sound you want
                                <br/># dogs making when you create your Dog class. Instead, we use the concept of method
                                <br/># overriding to change what the method does.
                                <br/>
                                <br/># overriding methods defined in the superclass
                                <br/>
                                <br/>class Animal:
                                <br/><span class="tab"></span>def makeSound(self):
                                <br/><span class="tab"></span><span class="tab"></span>print("Roar")
                                <br/>
                                <br/>
                                <br/>class Dog(Animal):
                                <br/><span class="tab"></span>def makeSound(self):
                                <br/><span class="tab"></span><span class="tab"></span>print("bark")
                                <br/>
                                <br/>
                                <br/>sam, lion = Dog(), Animal() <span class="tab"></span># declaring multiple variables on a single line
                                <br/>
                                <br/>sam.makeSound() <span class="tab"></span># overriding will call the makeSound method in Dog
                                <br/>lion.makeSound() <span class="tab"></span> # no overriding occurs as Animal does not inherit anything
                                <br/>
                                <br/>
                                <br/># Inheriting multiple classes
                                <br/>
                                <br/>
                                <br/># The main difference is how you super the attributes.
                                <br/># Rather than using the super method, you call the class name directly and pass in the self
                                <br/># parameter with the attributes. Lets see how:
                                <br/>
                                <br/>class Physics:
                                <br/><span class="tab"></span>gravity = 9.81
                                <br/>
                                <br/>
                                <br/>class Automobile:
                                <br/><span class="tab"></span>def __init__(self, make, model, year):
                                <br/><span class="tab"></span><span class="tab"></span>self.make, self.model, self.year = make, model, year
                                <br/># declaring all attributes on one line
                                <br/>
                                <br/>
                                <br/>class Ford(Physics, Automobile):
                                <br/><span class="tab"></span>def __init__(self, model, year):
                                <br/><span class="tab"></span><span class="tab"></span>Automobile.__init__(self, "Ford", model, year) <span class="tab"></span> # super does not work with multiple
                                <br/>
                                <br/>
                                <br/>truck = Ford("F-150", 2018)
                                <br/>print(truck.gravity, truck.make)
                                <br/>
                                <br/>
                                <br/># Thursday Exercises
                                <br/>
                                <br/>class Characters(object):
                                <br/><span class="tab"></span>def __init__(self, name, team, height=0, weight=0):
                                <br/><span class="tab"></span><span class="tab"></span>self.name, self.team, self.height, self.weight = name, team, height, weight
                                <br/>
                                <br/>def sayhello(self):
                                <br/><span class="tab"></span>return "Hello, my name is {} and I'm on the {} guys".format(self.name, self.team)
                                <br/>
                                <br/>
                                <br/>class goodPlayers(Characters):
                                <br/><span class="tab"></span>def __init__(self, name, team):
                                <br/><span class="tab"></span><span class="tab"></span>self.name, self.team = name, team
                                <br/><span class="tab"></span>super().__init__(name, team, height=0, weight=0)
                                <br/>
                                <br/>
                                <br/>class badPlayers(Characters):
                                <br/><span class="tab"></span>def __init__(self, name, team):
                                <br/><span class="tab"></span><span class="tab"></span>self.name, self.team = name, team
                                <br/><span class="tab"></span>super().__init__(name, team, height=0, weight=0)
                                <br/>
                                <br/>
                                <br/>G1 = goodPlayers("Max", "good")
                                <br/>B1 = badPlayers("Tony", "bad")
                                <br/>
                                <br/>print(G1.sayhello())
                                <br/>print(B1.sayhello())
                                <br/>

                        </p>
                    </section>
                    <section id="week8" class="main-section">
                        <header>
                            <h2>Week 8</h2>
                        </header>
                        <p class="support-text">
                            <br/># ADVANCED TOPICS : Efficiency
                            <br/>
                            <br/># MONDAY: LIST COMPREHENSION
                            <br/>
                            <br/># List comprehension allows us to create a list filled with data in a single line. Rather
                            <br/># than creating an empty list, iterating over some data, and appending it to the list all on
                            <br/># separate lines, we can use comprehension to perform all these steps at once.
                            <br/>
                            <br/>
                            <br/># SYNTAX = *result* = [*transform* *iteration* *filter*]
                            <br/>
                            <br/># For example, when you want to populate a list, the syntax would have the following
                            <br/># structure:
                            <br/>
                            <br/># name_of_list = [ item_to_append for item in list ]
                            <br/>
                            <br/># However, when you want to include an if statement, the comprehension would look
                            <br/># like the following:
                            <br/>
                            <br/># name_of_list = [ item_to_append for item in list if condition ]
                            <br/>
                            <br/># Lastly, if you would like to include an else condition, it would look like
                            <br/># the following:
                            <br/>
                            <br/># name_of_list = [ item_to_append if condition else item_to_append for item in list ]
                            <br/>
                            <br/># Generating a list of numbers
                            <br/>
                            <br/>nums = [x for x in range(100)]
                            <br/>print(nums)
                            <br/>
                            <br/>
                            <br/># using list statements within list comprehension
                            <br/>
                            <br/>nums = [x for x in range(10) if x % 2 == 0]
                            <br/>print(nums)
                            <br/>
                            <br/>
                            <br/># Using if/else statement within list comprehension
                            <br/>
                            <br/>nums = ["Even" if x % 2 == 0 else "odd" for x in range(10)]
                            <br/>print(nums)
                            <br/>
                            <br/>
                            <br/># list comprehension with variables
                            <br/>
                            <br/># creating a list of squared numbers from another list of numbers using list comprehension
                            <br/>
                            <br/>nums = [2, 4, 6, 8]
                            <br/>sq_nums = [num**2 for num in nums]
                            <br/>print(sq_nums)
                            <br/>
                            <br/>
                            <br/># DICTIONARY comprehension
                            <br/>
                            <br/># Not only can you use comprehension on lists but also Python dictionaries as well. The
                            <br/># syntax structure is the exact same, except you need to include a key-value pair instead of
                            <br/># a single number to insert into the dictionary.
                            <br/>
                            <br/># creating a dictionary of even numbers and square values using comprehension
                            <br/>
                            <br/>numbers = [x for x in range(10)]
                            <br/>squares = {num: num**2 for num in numbers if num % 2 == 0}
                            <br/>print(squares)
                            <br/>
                            <br/># Monday exercises
                            <br/>
                            <br/># 1 deg to farenheit
                            <br/>degrees = [12, 21, 15, 32]
                            <br/>faren = [((9/5)*i) + 32 for i in degrees]
                            <br/>print(faren)
                            <br/>
                            <br/># user input
                            <br/>num = 0
                            <br/>while num
                            <=1 00: <br/><span class="tab"></span>num = int(input("enter a number between 1 and 100: "))
                            <br/><span class="tab"></span>out = [x for x in range(1,101) if x%num == 0]
                            <br/><span class="tab"></span>print(out)
                            <br/>
                            <br/># Tuesday: Lambda functions
                            <br/>
                            <br/># Lambda functions, otherwise known as anonymous functions, are one-line functions
                            <br/># within Python. Like list comprehension, lambda functions allow us to reduce the lines of
                            <br/># code we need to write within our program. It doesn't work for complicated functions but
                            <br/># helps to improve readability of smaller functions.
                            <br/>
                            <br/># syntax:
                            <br/># lambda arguments : expression
                            <br/>
                            <br/># lambda arguments : value_to_return if condition else value_to_return
                            <br/>
                            <br/># using a lambda to square a number
                            <br/>(lambda x: print(x ** 2))(4)
                            <br/>
                            <br/># Passing multiple argument
                            <br/>(lambda x, y: print(x * y))(10, 5)
                            <br/>
                            <br/># saving a lambda function
                            <br/>
                            <br/>square = lambda x, y: x * y
                            <br/>print(square)
                            <br/>result = square(10, 5)
                            <br/>print(result)
                            <br/>
                            <br/># using conditional statements with a lambda to the greater number
                            <br/>
                            <br/>greater = lambda x, y: x if x > y else y
                            <br/>result = greater(5, 10)
                            <br/>print(result)
                            <br/>
                            <br/>
                            <br/># Returning a lambda
                            <br/>
                            <br/>
                            <br/>def myfunc(n):
                            <br/><span class="tab"></span>return lambda x: x * n
                            <br/>
                            <br/>
                            <br/>doubler = myfunc(2)
                            <br/>print(doubler(5))
                            <br/>tripler = myfunc(3)
                            <br/>print(tripler(5))
                            <br/>
                            <br/># Tuesday Exercises
                            <br/>
                            <br/>tf = (lambda x: True if x > 50 else False)
                            <br/>print(tf(55))
                            <br/>
                            <br/>faren = lambda D: ((9 / 5) * D) + 32
                            <br/>print(faren(12))
                            <br/>
                            <br/>
                            <br/># USING MAP, FILTER, and Reduce
                            <br/>
                            <br/># The map function is used to iterate over a data collection and modify it. The filter
                            <br/># function is used to iterate over a data collection, and you guessed it filter out data
                            <br/># that doesnt meet a condition. Lastly, the reduce function takes a data collection and
                            <br/># condenses it down to a single result, like the sum function for lists.
                            <br/>
                            <br/># Map without lambdas
                            <br/>
                            <br/>def convertDeg(C):
                            <br/><span class="tab"></span>return (9 / 5) * C + 32
                            <br/>
                            <br/>
                            <br/>temps = [12.5, 13.6, 15, 9.2]
                            <br/>converted_Temps = map(convertDeg, temps)
                            <br/>print(converted_Temps)
                            <br/>converted_Temps = list(converted_Temps)
                            <br/>print(converted_Temps)
                            <br/>
                            <br/># maps with lambdas
                            <br/>
                            <br/>temps = [12.5, 13.6, 15, 9.2]
                            <br/>converted_Temps = list(map(lambda C: (9 / 5) * C + 32, temps))
                            <br/>print(converted_Temps)
                            <br/>
                            <br/>
                            <br/># filter without lambda
                            <br/>
                            <br/>def filtertemps(C):
                            <br/><span class="tab"></span>converted = (9 / 5) * C + 32
                            <br/><span class="tab"></span>return True if converted > 55 else False
                            <br/>
                            <br/>
                            <br/>temps = [12.5, 13.6, 15, 9.2]
                            <br/>filtered_temps = filter(filtertemps, temps)
                            <br/>print(filtered_temps)
                            <br/>filtered_temps = list(filtered_temps)
                            <br/>print(filtered_temps)
                            <br/>
                            <br/># filter with lambdas
                            <br/>temps = [12.5, 13.6, 15, 9.2]
                            <br/>filtered_temps = list(filter(lambda C: True if (9 / 5) * C + 32 > 55 else False, temps))
                            <br/># type convert the filter
                            <br/>print(filtered_temps)
                            <br/>
                            <br/># The problem with reduce
                            <br/># So now reduce(). This is actually the one I've always hated most, because,
                            <br/># apart from a few examples involving + or , almost every time I see a
                            <br/># reduce() call with a non-trivial function argument, I need to grab pen and
                            <br/># paper to diagram what's actually being fed into that function before I
                            <br/># understand what the reduce() is supposed to do. So in my mind, the applicability of
                            <br/># reduce() is pretty much limited to associative operators, and in
                            <br/># all other cases it's better to write out the accumulation loop explicitly.
                            <br/>
                            <br/>
                            <br/># Using reduce
                            <br/>
                            <br/># The reduce function accepts two arguments, the function to perform the execution and
                            <br/># the data collection to iterate over. Unlike filter and map, however, reduce iterates two
                            <br/># items at a time instead of one. The result of reduce is to always return a single result.
                            <br/>
                            <br/>from functools import reduce
                            <br/>
                            <br/>nums = [1, 2, 3, 4]
                            <br/>result = reduce(lambda a, b: a * b, nums)
                            <br/>print(result)
                            <br/>
                            <br/>
                            <br/># Wednesday Exercises
                            <br/># 1
                            <br/>
                            <br/>names = ['Ryan', 'Paul', 'Kevin Connors']
                            <br/>result = list(map(lambda x: (x.lower()), names))
                            <br/>print(result)
                            <br/>
                            <br/>#2
                            <br/>result = []
                            <br/>names = ["Amanda", "Frank", "abby", "Ripal", "Adam"]
                            <br/>for i in range(len(names)):
                            <br/><span class="tab"></span>if names[i][0] in ['A', 'a']:
                            <br/><span class="tab"></span><span class="tab"></span>continue
                            <br/><span class="tab"></span>else:
                            <br/><span class="tab"></span><span class="tab"></span>result.append(names[i])
                            <br/>
                            <br/>print(result)
                            <br/>
                            <br/># challenge
                            <br/>
                            <br/>LamFil = list(filter(lambda x: x[i] if x[i in range(len(x))][0] not in ['A', 'a'] else False, names))
                            <br/>print(LamFil)
                            <br/>
                            <br/># Thursday : Recursive Functions and Memoization
                            <br/>
                            <br/># Recursion is a concept in programming where a function calls itself one or more times
                            <br/># within its block. These types of functions can often run into issues with speed, however,
                            <br/># due to the function constantly calling itself. Memoization helps this process by storing
                            <br/># values that were already calculated to be used later. Lets first understand more about
                            <br/># recursive functions.
                            <br/>
                            <br/># All recursive functions have what is known as a base case, or a stopping point.
                            <br/>
                            <br/># Writing a factorial function
                            <br/>def factorial(n):
                            <br/><span class="tab"></span># set your base case!
                            <br/><span class="tab"></span>if n
                            <=1 : <br/><span class="tab"></span><span class="tab"></span>return 1
                            <br/><span class="tab"></span>else:
                            <br/><span class="tab"></span><span class="tab"></span>return factorial(n - 1) * n
                            <br/>
                            <br/>
                            <br/>print(factorial(10)) # the result of 5*4*3*2*1
                            <br/>
                            <br/>
                            <br/># The fibonacci Series
                            <br/>
                            <br/># Each number in the
                            <br/># sequence is the sum of the previous two numbers, such that fib(5) = fib(4) + fib(3).
                            <br/># The base case for the Fibonacci sequence is 0 and 1 because the result of fib(2) is
                            <br/># fib(2) = fib(1) + fib(0)
                            <br/>
                            <br/># writing the recursive fibonacci sequence
                            <br/>def fib(n):
                            <br/><span class="tab"></span>if n
                            <=1 : <br/><span class="tab"></span><span class="tab"></span>return n
                            <br/><span class="tab"></span>else:
                            <br/><span class="tab"></span><span class="tab"></span>return fib(n - 1) + fib(n - 2)
                            <br/>
                            <br/>
                            <br/>print(fib(5))
                            <br/>
                            <br/># Understanding Memoization
                            <br/>
                            <br/># When you go to a web page for the first time, your browser takes a little while to load the
                            <br/># images and files required by the page. The second time you go to the exact same page, it
                            <br/># usually loads much faster. This is because your browser is using a technique known as
                            <br/># caching. When you loaded the page the first time, it saved the images and files locally.
                            <br/># The second time you accessed the web page, instead of re-downloading all the images and
                            <br/># files, it simply loaded them from the cache. This improves our experiences on the Web.
                            <br/># In computing, memoization is an optimization technique used primarily to speed
                            <br/># up computer programs by storing the results of previously called functions and returning
                            <br/># the saved result when trying to calculate the same sequence. This is simply known as
                            <br/># caching,
                            <br/>
                            <br/># Using Memoization
                            <br/>
                            <br/>cache = {} <span class="tab"></span># # used to cache values to be used later
                            <br/>
                            <br/>
                            <br/>def fib(n):
                            <br/><span class="tab"></span>if n in cache:
                            <br/><span class="tab"></span><span class="tab"></span>return cache[n] # return value stored in dictionary
                            <br/><span class="tab"></span>result = 0
                            <br/>
                            <br/><span class="tab"></span># base case
                            <br/><span class="tab"></span>if n
                            <=1 : <br/><span class="tab"></span><span class="tab"></span>result = n
                            <br/>
                            <br/><span class="tab"></span>else:
                            <br/><span class="tab"></span><span class="tab"></span>result = fib(n - 1) + fib(n - 2)
                            <br/>
                            <br/><span class="tab"></span>cache[n] = result
                            <br/><span class="tab"></span>return result
                            <br/>
                            <br/>
                            <br/>print(fib(50)) <span class="tab"></span># else it will take weeks to solve fib 50
                            <br/>
                            <br/># Memoization is not perfect; there is a limit to how much you can store in a
                            <br/># single cache.
                            <br/>
                            <br/>
                            <br/># Using @lru_Cache
                            <br/>
                            <br/>from functools import lru_cache
                            <br/>
                            <br/>
                            <br/>@lru_cache() <span class="tab"></span># pythons built-in memoization/caching system
                            <br/>def fib(n):
                            <br/><span class="tab"></span>if n
                            <=1 : <br/><span class="tab"></span><span class="tab"></span>return n
                            <br/><span class="tab"></span>else:
                            <br/><span class="tab"></span><span class="tab"></span>return fib(n - 1) + fib(n - 2)
                            <br/>
                            <br/>
                            <br/>print(fib(50))
                            <br/>
                            <br/># Thursday exercise
                            <br/>
                            <br/>from functools import lru_cache
                            <br/>
                            <br/>
                            <br/>@lru_cache()
                            <br/>def factorial(n):
                            <br/><span class="tab"></span># set your base case!
                            <br/><span class="tab"></span>if n
                            <=1 : <br/><span class="tab"></span><span class="tab"></span>return 1
                            <br/><span class="tab"></span>else:
                            <br/><span class="tab"></span><span class="tab"></span>return factorial(n - 1) * n
                            <br/>
                            <br/>
                            <br/>print(factorial(11))
                            <br/>
                            <br/># 2
                            <br/># SEARCHING DATA
                            <br/>
                            <br/># Look again
                            <br/>
                            <br/>lists = [2, 3, [18, 22], 6]
                            <br/>element = 22
                            <br/>V = False
                            <br/>j = 0
                            <br/>for i in range(len(lists)):
                            <br/>try:
                            <br/><span class="tab"></span>if element in lists[i]:
                            <br/><span class="tab"></span><span class="tab"></span>j = j + 1
                            <br/><span class="tab"></span><span class="tab"></span>V = True
                            <br/>
                            <br/><span class="tab"></span>except:
                            <br/><span class="tab"></span><span class="tab"></span>if element in lists:
                            <br/><span class="tab"></span><span class="tab"></span>V = True
                            <br/>
                            <br/>print(V)
                            <br/>
                            <br/>
                            <br/># by recursion of function
                            <br/>
                            <br/>
                            <br/>def SearchList(a, b):
                            <br/><span class="tab"></span>if b in a:
                            <br/><span class="tab"></span><span class="tab"></span>return True
                            <br/><span class="tab"></span>for i in range(len(a)):
                            <br/><span class="tab"></span><span class="tab"></span>if type(a[i]) == list:
                            <br/><span class="tab"></span><span class="tab"></span><span class="tab"></span>return SearchList(a[i], b)
                            <br/><span class="tab"></span><span class="tab"></span>elif b in a:
                            <br/><span class="tab"></span><span class="tab"></span><span class="tab"></span>return True
                            <br/><span class="tab"></span>else:
                            <br/><span class="tab"></span><span class="tab"></span>return False
                            <br/>
                            <br/>
                            <br/>print(SearchList([2, 3, [18, 22], 6], 22))
                            <br/>
                            <br/>
                            <br/># Writing a binary search
                            <br/>
                            <br/>import random
                            <br/>
                            <br/># nums = [1,5,55,7,12,23,45,99,100]
                            <br/>nums = [random.randint(0, 20) for i in range(10)]
                            <br/>
                            <br/>
                            <br/>def binarySearch(aList, num):
                            <br/><span class="tab"></span>aList.sort()
                            <br/><span class="tab"></span>while aList:
                            <br/><span class="tab"></span><span class="tab"></span>mid = len(aList) // 2
                            <br/><span class="tab"></span><span class="tab"></span>if mid == num:
                            <br/><span class="tab"></span><span class="tab"></span><span class="tab"></span>return True
                            <br/><span class="tab"></span><span class="tab"></span>elif mid > num:
                            <br/><span class="tab"></span><span class="tab"></span><span class="tab"></span>aList = aList[:mid]
                            <br/><span class="tab"></span><span class="tab"></span>elif mid
                            < num: <br/><span class="tab"></span><span class="tab"></span><span class="tab"></span>aList = aList[mid + 1:]
                            <br/><span class="tab"></span><span class="tab"></span>return False
                            <br/>
                            <br/>print(sorted(nums))
                            <br/>print(binarySearch(nums, 23))
                            <br/>
                        </p>
                    </section>
                    <section id="week9" class="main-section">
                        <header>
                            <h2>Week 9</h2>
                        </header>
                        <p class="support-text">
                            <br />
                            <br /># Monday: Generators and Iterators
                            <br />
                            <br /># you may have seen the words generators or iterators
                            <br /># mentioned. Without knowing, youve been using them the entire time. Today, well dive
                            <br /># into what each of these concepts are and how to use them.
                            <br />
                            <br /># An iterator is an object that contains items which can be iterated upon, meaning
                            <br /># you can traverse through all values. An iterable is a collection like lists, dictionaries,
                            <br /># tuples, and sets. The major difference is that iterables are not iterators; rather they are
                            <br /># containers for data.
                            <br />
                            <br /># Creating a basic Iterator
                            <br />
                            <br />sports = ["baseball", "soccer", "football", "hockey", "basketball"]
                            <br />my_iter = iter(sports)
                            <br />print(next(my_iter))
                            <br />print(next(my_iter))
                            <br />for item in my_iter:
                            <br /><span class="tab"></span>print(item)
                            <br />
                            <br />
                            <br /># print(next(my_iter)) <span class="tab"></span> # Will produce error
                            <br />
                            <br />
                            <br /># Creating our own iterator
                            <br />
                            <br />class Alphabet():
                            <br /><span class="tab"></span>def __iter__(self):
                            <br /><span class="tab"></span><span class="tab"></span>self.letters = 'abcdefghijklmnopqrstuvwxyz'
                            <br /><span class="tab"></span><span class="tab"></span>self.index = 0
                            <br /><span class="tab"></span><span class="tab"></span>return self
                            <br />
                            <br /><span class="tab"></span>def __next__(self):
                            <br /><span class="tab"></span><span class="tab"></span>if self.index
                            <=2 5: <br /><span class="tab"></span><span class="tab"></span><span class="tab"></span>char = self.letters[self.index]
                            <br /><span class="tab"></span><span class="tab"></span><span class="tab"></span>self.index += 1
                            <br /><span class="tab"></span><span class="tab"></span><span class="tab"></span>return char
                            <br /><span class="tab"></span><span class="tab"></span>else:
                            <br /><span class="tab"></span><span class="tab"></span><span class="tab"></span>raise StopIteration
                            <br />
                            <br />
                            <br />for char in Alphabet():
                            <br /><span class="tab"></span>print(char)
                            <br />
                            <br />
                            <br /># GENERATORS
                            <br />
                            <br /># Generators are functions that yield back information to produce a sequence of results
                            <br /># rather than a single value. Theyre a way to simplify the creation of an iterator. Normally,
                            <br /># when a function has completed its task and returned information, the variables declared
                            <br /># inside of the function will be deleted. With generators, however, they use the yield
                            <br /># keyword to send information back to the location it was called without terminating the
                            <br /># function. Generators dont always have to yield back integers though you can yield any
                            <br /># information youd like.
                            <br />
                            <br />
                            <br /># creating a range generator
                            <br />
                            <br />
                            <br />def myRange(stop, start=0, step=1):
                            <br /><span class="tab"></span>while start
                            < stop: <br /><span class="tab"></span><span class="tab"></span>print("Generator Start value: {}".format(start))
                            <br /><span class="tab"></span><span class="tab"></span>yield start
                            <br /><span class="tab"></span><span class="tab"></span>start += step
                            <br />
                            <br />
                            <br />for x in range(5):
                            <br /><span class="tab"></span>print("For loop X value: {}".format(x))
                            <br />
                            <br />
                            <br />
                            <br /># Tuesday Decorators
                            <br />
                            <br /># Decorators, also known as wrappers, are functions that give other functions extra
                            <br /># capabilities without explicitly modifying them. They are denoted by the @ symbol
                            <br /># in front of the function name, which is written above a function declaration like the
                            <br /># following:
                            <br /># @decorator
                            <br /># def normalfunc():
                            <br />
                            <br />
                            <br /># Higher-Order Functions
                            <br />
                            <br /># A higher-order function is a function that operates on other functions, either by taking
                            <br /># a function as its argument or by returning a function.
                            <br />
                            <br />
                            <br /># Creating and Applying a Decorator
                            <br />
                            <br />def decorator(func):
                            <br /><span class="tab"></span>def wrap():
                            <br /><span class="tab"></span><span class="tab"></span>print("=======")
                            <br /><span class="tab"></span>func()
                            <br /><span class="tab"></span>print("=======")
                            <br />
                            <br /><span class="tab"></span>return wrap
                            <br />
                            <br />
                            <br />@decorator
                            <br />def printName():
                            <br /><span class="tab"></span>print("John!")
                            <br />
                            <br />
                            <br />printName()
                            <br />
                            <br />
                            <br /># creating a decorator that takes in parameters
                            <br />
                            <br />
                            <br />def run_times(num):
                            <br /><span class="tab"></span>def wrap(func):
                            <br /><span class="tab"></span><span class="tab"></span>for i in range(num):
                            <br /><span class="tab"></span><span class="tab"></span><span class="tab"></span>func()
                            <br />
                            <br /><span class="tab"></span>return wrap
                            <br />
                            <br />
                            <br />@run_times(4)
                            <br />def sayHello():
                            <br /><span class="tab"></span>print("Hello!")
                            <br />
                            <br />
                            <br /># When passing an argument into a decorator, the function is automatically
                            <br /># run, so we do not need to call sayHello in this instance
                            <br />
                            <br /># Functions with decorators and parameters
                            <br />
                            <br />def birthday(func):
                            <br /><span class="tab"></span>def wrap(name, age):
                            <br /><span class="tab"></span><span class="tab"></span>func(name, age + 1)
                            <br />
                            <br /><span class="tab"></span>return wrap
                            <br />
                            <br />
                            <br />@birthday
                            <br />def celebrate(name, age):
                            <br /><span class="tab"></span>print("Happy birthday {}, you are now {}".format(name, age))
                            <br />
                            <br />
                            <br />celebrate("paul", 43)
                            <br />
                            <br />
                            <br /># Restricting function access
                            <br />
                            <br /># real world sim, restricting function access
                            <br />
                            <br />def login_required(func):
                            <br /><span class="tab"></span>def wrap(user):
                            <br /><span class="tab"></span><span class="tab"></span>password = input("What is the password?")
                            <br /><span class="tab"></span><span class="tab"></span>if password == user["password"]:
                            <br /><span class="tab"></span><span class="tab"></span><span class="tab"></span>func(user)
                            <br /><span class="tab"></span><span class="tab"></span>else:
                            <br /><span class="tab"></span><span class="tab"></span><span class="tab"></span>print("Access Denied")
                            <br />
                            <br /><span class="tab"></span>return wrap
                            <br />
                            <br />
                            <br />@login_required
                            <br />def restrictedFunc(user):
                            <br /><span class="tab"></span>print("Access granted, welcome {}".format(user["name"]))
                            <br />
                            <br />
                            <br />user = {"name": "Jess", "password": "ilywpf"}
                            <br />restrictedFunc(user)
                            <br />
                            <br />
                            <br /># Tuesday Exercises
                            <br />
                            <br />def number(func):
                            <br /><span class="tab"></span>def wrap(num):
                            <br /><span class="tab"></span><span class="tab"></span>if num
                            < 100: <br /><span class="tab"></span><span class="tab"></span><span class="tab"></span>func(num)
                            <br /><span class="tab"></span><span class="tab"></span>else:
                            <br /><span class="tab"></span><span class="tab"></span><span class="tab"></span>None
                            <br /><span class="tab"></span>return wrap
                            <br />
                            <br />@number
                            <br />def numbers(num):
                            <br /><span class="tab"></span>print("Less than 100")
                            <br />
                            <br />
                            <br />num = 99
                            <br />numbers(num)
                            <br />
                            <br />
                            <br /># 2
                            <br />
                            <br />def route(stringIn):
                            <br /><span class="tab"></span>def wrap(func):
                            <br /><span class="tab"></span><span class="tab"></span>print(stringIn)
                            <br /><span class="tab"></span><span class="tab"></span><span class="tab"></span>func()
                            <br /><span class="tab"></span>return wrap
                            <br />
                            <br />
                            <br />@route("/index")
                            <br />def index():
                            <br /><span class="tab"></span>print("This is how web pages are made in Flask")
                            <br />
                            <br />
                            <br /># MODULES
                            <br />
                            <br /># Most programs tend to include so many lines of code that you wouldnt store it all within
                            <br /># a single file. Instead you separate the code into several files, which helps to keep the
                            <br /># project organized. Each one of these files is known as modules. Within these modules
                            <br /># are variables, functions, classes, etc., that you can import into a project.
                            <br />
                            <br />
                            <br /># import the entire math module
                            <br />import math
                            <br />
                            <br />print(math.floor(2.5)) # rounds down
                            <br />
                            <br />print(math.ceil(2.5)) # round up
                            <br />
                            <br />print(math.pi)
                            <br />
                            <br /># importing only variables and functions rather than an entire module, better efficiency
                            <br />from math import floor, pi
                            <br />
                            <br />print(floor(2.5))
                            <br /># print( ceil(2.5) ) # will cause error as not imported
                            <br />
                            <br />print(pi)
                            <br />
                            <br /># Often, the name of what youd like to import can be lengthy. Rather than having to write
                            <br /># out an entire name each time youd like to use it, you can give an alias or nickname
                            <br /># when importing:
                            <br />
                            <br />
                            <br />from math import floor as f
                            <br />
                            <br />print(f(2.5))
                            <br />
                            <br /># Creating your own module in text editor file test.py
                            <br />
                            <br /># Using our module
                            <br />
                            <br />from test import length, width, printInfo
                            <br />print(length, width)
                            <br />printInfo("John Smith", 37)
                            <br />
                            <br /># Wednesday Exercises
                            <br />
                            <br />import time as t
                            <br />t.sleep(5)
                            <br />print("Time module imported")
                            <br />
                            <br />
                            <br />from calculation import calArea
                            <br />calArea(15, 30)
                            <br />
                            <p class="support-text">
                                <br /># Understanding time Complexity
                                <br />
                                <br /># Todays focus is primarily on the theory of programming and
                                <br /># algorithms. If there is a theory in programming that you should understand, it should be
                                <br /># Big O Notation.
                                <br />
                                <br /># As a software engineer, youll often need to estimate the amount of time a program may
                                <br /># take to execute. In order to give a proper estimate, you must know the time complexity of
                                <br /># the program. This is where algorithmic complexity comes in to play, otherwise known as
                                <br /># Big O Notation. It is the concept to describe how long an algorithm or program takes to
                                <br /># execute. Take a list, for example. As the number of items within the list grows, so does the
                                <br /># amount of time it takes to iterate over the list. This is known as O(n), where n represents
                                <br /># the number of operations. Its called Big O Notation because you put a Big O in front of
                                <br /># the number of operations.
                                <br /># Big O establishes a worst-case scenario runtime. Even if you search through a list of
                                <br /># 100 items and find what youre looking for on the first try, this would still be considered
                                <br /># O(100) because it could possibly take up to 100 operations.
                                <br /># The most efficient Big O Notation is O(1), also known as constant time. It means that
                                <br /># no matter how many items or steps are required, it will always take the same amount of
                                <br /># time and generally occurs instantly. If we took the same list of 100 items and accessed
                                <br /># an index directly, this would be known as O(1). We would retrieve the value in that index
                                <br /># immediately without needing to iterate over the list.
                                <br /># One of the least efficient time complexities is O(n2). This is a representation of
                                <br /># a double loop. Our Bubble Sort algorithm that we wrote uses a double for loop and is
                                <br /># known as one of the less efficient sorting algorithms in programming; however, it is
                                <br /># simple to understand, so it makes for a good introduction into algorithms. Well see
                                <br /># later today how Bubble Sort compares to another algorithm that is designed to be
                                <br /># much more efficient.
                                <br />
                                <br />
                                <br /># When you compare a simple search that iterates through each element of a list to
                                <br /># an efficient algorithm like Binary Search, you begin to see that they dont grow at the
                                <br /># same rate over time. Take Table-1 that illustrates the amount of time to search for a
                                <br /># given item.
                                <br />
                                <br />
                                <br /># Table 9-1. Big O Notation growth rate comparison1
                                <br /># Number of Elements Simple Search Binary Search
                                <br />
                                <br />
                                <br /># The runtime in Big O Notation<span class="tab"></span><span class="tab"></span>O(n)<span class="tab"></span><span class="tab"></span>O(log n)
                                <br /># 10 <span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="tab"></span> 10 ms <span class="tab"></span><span class="tab"></span>                                3 ms
                                <br /># 100 <span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="tab"></span> 100 ms <span class="tab"></span><span class="tab"></span>                                7 ms
                                <br /># 10,000 <span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="tab"></span> 10 sec <span class="tab"></span> <span class="tab"></span> 14 ms
                                <br /># 1,000,000,000<span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="tab"></span> 11 days <span class="tab"></span><span class="tab"></span> 32 ms
                                <br />
                                <br />
                                <br /># We can clearly see that efficient algorithms can help to improve our programs speed.
                                <br /># Therefore, its important to keep efficiency and time complexity in mind when writing
                                <br /># your code.
                                <br />
                                <br /># You should learn more about BigO.
                                <br />
                                <br />
                                <br /># Hash Tables
                                <br />
                                <br /># When we originally covered dictionaries, we went over hashing very briefly. Now that
                                <br /># weve covered Big O Notation, understanding hash tables and why theyre important is
                                <br /># much easier. Dictionaries can be accessed in O(1) complexity because of how they are
                                <br /># stored in memory. They use hash tables to store the key-value pairs. Before we cover
                                <br /># hash tables though, lets have a quick refresher on the hash function and how to use it:
                                <br />
                                <br />a, c = "bo", 'bob'
                                <br />b = a
                                <br />print(hash(a), hash(b), hash(c))
                                <br />
                                <br /># When dictionaries store key-value pairs into memory, they use this concept. A hash
                                <br /># table is used to store a hash, a key, and a value. The hash stored is used for when you
                                <br /># need to retrieve a given value by the key. Take Table 9-2, for instance. There are three
                                <br /># key-value pairs in place, all with different hash values. When you want to acces the value
                                <br /># for name, you would write:
                                <br />
                                <br /># person["name"]
                                <br />
                                <br /># What happens is Python hashes the string name and looks for the hash value
                                <br /># rather than the key itself. You can think of this like retrieving an item within a list by its
                                <br /># index. This is much more efficient as you can retrieve values based on hashes almost
                                <br /># instantly at O(1) time.
                                <br />
                                <br /># Table 9-2. Logical representation of
                                <br /># Python hash table
                                <br /># Hash <span class="tab"></span> <span class="tab"></span> Key <span class="tab"></span> <span class="tab"></span> Value
                                <br /># 2839702572 <span class="tab"></span> Name <span class="tab"></span> John Smith
                                <br /># 8267348712 <span class="tab"></span> Age <span class="tab"></span> <span class="tab"></span> 32
                                <br /># -2398350273 <span class="tab"></span> Language <span class="tab"></span> Python
                                <br />
                                <br /># Dictionaries are helpful data collections for not only keeping information connected
                                <br /># but also improving efficiency. Keep this in mind when youre trying to answer
                                <br /># programming questions or making a program faster. Like the information on Big O
                                <br /># Notation, this is simply an introduction into hash tables. If youd like to learn more, be
                                <br /># sure to look it up using Google, Quora, etc.
                                <br />
                                <br />
                                <br /># Dictionaries vs. List
                                <br />
                                <br /># To understand the true power of a hash table and Python dictionaries, lets compare it
                                <br /># against a list. Well write a conditional statement to have Python check for a given item
                                <br /># within a dictionary and list, and well time how long each one takes. Were going to
                                <br /># separate the code into two cells. The first cell will generate the dictionary and list with 10
                                <br /># million items:
                                <br />
                                <br /># creating data collections to test for time complexity
                                <br /></p>
                            <br />import time
                            <br />
                            <br />d = {} # generate fake dictionary
                            <br />for i in range(10000000):
                            <br /><span class="tab"></span>d[i] = "value"
                            <br />big_list = [x for x in range(10000000)] <span class="tab"></span># generate fake list
                            <br />
                            <br /># Go ahead and run the cell. Nothing will happen yet. Weve simply made the variables
                            <br /># within this cell so that we dont have to re-create them, as it takes a couple seconds
                            <br /># depending on your computer. In the following cell, were going to keep a timer on how
                            <br /># long each data collection takes to find the last element. Well use the time module in
                            <br /># order to track the start and end time:
                            <br />
                            <br /># retrieving information and tracking time to see which is faster
                            <br />start_time = time.time() <span class="tab"></span> # Tracking time for dictionary
                            <br />if 9999999 in d:
                            <br /><span class="tab"></span>print("Found in dictionary")
                            <br /><span class="tab"></span>end_time = time.time() - start_time
                            <br /><span class="tab"></span>print("Elapsed time for dictionary: {}".format(end_time))
                            <br />
                            <br />start_time = time.time() <span class="tab"></span># Tracking time for list
                            <br />if 9999999 in big_list:
                            <br /><span class="tab"></span>print("Found in list")
                            <br /><span class="tab"></span>end_time = time.time()-start_time
                            <br />print("Elapsed time for list: {}".format(end_time))
                            <br />
                            <br /># Youll notice theres a large difference between the two times. The list
                            <br /># will usually take between 1 and 1.5 seconds, whereas the dictionary is almost instant
                            <br /># every time. Now this doesn't seem like that big of a difference, but what if you needed
                            <br /># to search for 1000 items. Using a list now becomes a problem, as a dictionary would
                            <br /># continue to do it instantly, but the list would take much longer.
                            <br />
                            <br /># Battle of algorithms
                            <br />
                            <br /># testing bubble sort vs. insertion sort
                            <br />
                            <br />def bubbleSort(aList):
                            <br /><span class="tab"></span>for i in range(len(aList)):
                            <br /><span class="tab"></span><span class="tab"></span>switched = False
                            <br /><span class="tab"></span><span class="tab"></span>for j in range(len(aList)-1):
                            <br /><span class="tab"></span><span class="tab"></span><span class="tab"></span>if aList[j] > aList[j+1]:
                            <br /><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="tab"></span>aList[j], aList[j+1] = aList[j+1], aList[j]
                            <br /><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="tab"></span>switched = True
                            <br /><span class="tab"></span><span class="tab"></span><span class="tab"></span>if switched == False:
                            <br /><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="tab"></span>break
                            <br /><span class="tab"></span>return aList
                            <br />
                            <br />def insertionSort(aList):
                            <br /><span class="tab"></span>for i in range(1,len(aList)):
                            <br /><span class="tab"></span><span class="tab"></span>if aList[i]
                            < aList[i-1]: <br /><span class="tab"></span><span class="tab"></span><span class="tab"></span>for j in range(i, 0, -1):
                            <br /><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="tab"></span>if aList[j]
                            < aList[j - 1]: <br /><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="tab"></span><span class="tab"></span>aList[j], aList[j+1] = aList[j+1], aList[j]
                            <br />
                            <br /><span class="tab"></span><span class="tab"></span>else:
                            <br /><span class="tab"></span><span class="tab"></span><span class="tab"></span>break
                            <br /><span class="tab"></span>return aList
                            <br />
                            <br /># Calling bubble sort and insertion sort to test time complexity
                            <br />
                            <br />
                            <br />from random import randint
                            <br />nums = [randint(0, 100) for x in range(5000)]
                            <br />start_time = time.time() <span class="tab"></span> # tracking time bubble sort
                            <br />bubbleSort(nums)
                            <br />end_time = time.time() - start_time
                            <br />print("Elapsed time for Bubble Sort: {}".format(end_time))
                            <br />
                            <br />start_time = time.time() <span class="tab"></span> # tracking time insertion sort
                            <br />insertionSort(nums)
                            <br />end_time = time.time( ) - start_time
                            <br />print("Elapsed time for Insertion Sort: {}".format(end_time))
                            <br />
                            <br /># Thursday exercise
                            <br /># 1
                            <br /># n(log(n)) for merge sort algorithm
                            <br /># 9999999 guesses



                        </p>
                    </section>
                    <section id="week10" class="main-section">
                        <header>
                            <h2>Week 10</h2>
                        </header>
                        <p class="support-text">

                            <br/># introduction to data analysis
                            <br/>
                            <p class="support-class">
                                <br/># Well learn about the Pandas library and how to work with tabular data structures,
                                <br/># web scraping with BeautifulSoup and understanding how to parse data, as well as data
                                <br/># visualization libraries like matplotlib. At the end of the week, well use all these libraries
                                <br/># together to create a small project that scrapes and analyzes web sites.
                                <br/># Overview
                                <br/>#  Working with Anaconda environments and sending requests
                                <br/>#  Learning how to analyze tabular data structures with Pandas
                                <br/>#  Understanding how to present data using matplotlib
                                <br/>#  Using the BeautifulSoup library to scrape the Web for data
                                <br/>#  Creating a web site analysis tool
                                <br/>
                                <br/>
                                <br/># Monday: Virtual Environments and Requests Module
                                <br/>
                                <br/># Today well be learning all about virtual environments, why we need them and how to
                                <br/># use them. Theyre necessary for what we need to do this week, which is downloading
                                <br/># and importing a few libraries to work with. Well also get into the requests module and
                                <br/># cover APIs briefly.
                                <br/>
                                <br/># What Are Virtual Environments?
                                <br/>
                                <br/># Python virtual environments are essentially a tool that allows you to keep project
                                <br/># dependencies in a separate space from other projects. Most projects in Python need
                                <br/># to use modules that are not included by default with Python. Now, you could simply
                                <br/># download the modules (or libraries) into your Python folder to use; however, that could
                                <br/># cause some issues down the road. Lets say youre working on two separate projects,
                                <br/># where the first one uses Python version 2.7 and the second project uses Python version
                                <br/># 3.5. If you try and use the same syntax for both, youll run into several issues. Instead,
                                <br/># you would create two separate virtual environments, one for each project. This way both
                                <br/># projects can run properly using the correct dependencies because of the personalized
                                <br/># virtual environment.
                                <br/>
                                <br/>
                                <br/># When creating a virtual environment, a folder called venv  will appear.
                                <br/># This is where all the libraries that you download are saved. Simply put, a virtual
                                <br/># environment is not much more than a folder that stores other files.
                                <br/>
                                <br/># As an analogy to understand virtual environments, first picture our own planet.
                                <br/># Now think of it as an environment filled with grass, sun, clouds, air, etc. In the case
                                <br/># of programming, Python would be like the planet, and the grass, sun, clouds, and air
                                <br/># would be like libraries that you need to include in the environment. As Python does
                                <br/># not come included with them, we would create a virtual environment to store these
                                <br/># libraries so that we may import them into our project when needed. If you think of
                                <br/># Mars, that would be another project, with a separate virtual environment specifically
                                <br/># made for that program.
                                <br/># Virtual environments can often be a tough concept to grasp for anyone seeing it
                                <br/># for the first time, so heres another analogy. Imagine youve planned two vacations,
                                <br/># one to the beach and the other to go skiing. Rather than using the same suitcase
                                <br/># filled with mixed clothes, youve decided to pack two separate suitcases. The one for
                                <br/># the beach will include a bathing suit, sunglasses, and flip-flops. The other suitcase
                                <br/># will include a jacket, skis, and boots. In the following, you can find the relationships
                                <br/># within this analogy:
                                <br/>#  Vacations <span class="tab"></span>  Projects
                                <br/>#  Suitcases <span class="tab"></span>  Virtual Environments
                                <br/>#  Clothes and Accessories <span class="tab"></span>  Project Dependencies/Files
                                <br/>
                                <br/>
                                <br/># Remember from the first chapter, when working in terminal, youll see the
                                <br/># $ next to the commands that we enter. For the next few sections, well be working
                                <br/># inside of terminal.
                                <br/>
                                <br/># What Is Pip?
                                <br/>
                                <br/># Pip is the standard package manager for Python. Anytime you need to download,
                                <br/># uninstall, or manage a library or module to use within your project, you use pip. It has
                                <br/># been included in all installations of Python since v3.4. To check your version of pip, write
                                <br/># the following in terminal:
                                <br/>
                                <br/># $ pip --version
                                <br/>
                                <br/># Creating a Virtual Environment
                                <br/>
                                <br/># $ conda create --name data_analysis python=3.7
                                <br/>
                                <br/># You can create a conda environment from anywhere; you do not need to be
                                <br/># cded into a specific folder.
                                <br/>
                                <br/>
                                <br/># An application programming interface (API) is a set of functions and procedures
                                <br/># that allow applications to access the features or data of an operating system, application,
                                <br/># or other service. In a simpler description, APIs allow us to interact with web pages
                                <br/># and software designed by other developers. Imagine you need some data on housing
                                <br/># prices. Rather than collecting all that information yourself, you could use the resources
                                <br/># that major companies like Zillow and Trulia have put together. In order to access
                                <br/># that information, you need to call their API, which will return the data that you need.
                                <br/># APIs make a developers life easier because we can use data or tools created by other
                                <br/># companies within our projects.
                                <br/>
                                <p/>
                                <br/># Sending a Request
                                <br/>import requests
                                <br/>r = requests.get("https://api.github.com/users/Connor-SM")
                                <br/>print(r)
                                <br/>print(type(r))
                                <br/>
                                <br/># Accessing the response Content
                                <br/>data = r.content
                                <br/>print(data)
                                <br/>
                                <br/># converting the Response from JSON into a python Dictionary
                                <br/>data = r.json()
                                <br/>for k, v in data.items():
                                <br/>print("Key: {} \t Value: {}".format(k, v))
                                <br/>print(data["name"]) <span class="tab"></span># accessing data directly
                                <br/>
                                <br/># Passing Parameters
                                <br/># outputting specific key-value pairs from data
                                <br/>r = requests.get("https://api.github.com/search/repositories?q=language:python")
                                <br/>data = r.json()
                                <br/>print(data["total_count"]) <span class="tab"></span># output the total number of repositories that use python
                                <br/>
                                <br/># Monday Exercises
                                <br/>r = requests.get("https://api.github.com/search/repositories?q=language:javaScript")
                                <br/>data = r.json()
                                <br/>print(data["total_count"])
                                <br/>
                                <p class="support-text">
                                    <br/># Pandas
                                    <br/>#
                                    <br/># When you need to work with data, Pandas is the ultimate tool. Its essentially Excel on
                                    <br/># steroids. If youre familiar with the SQL language, this will come easier to you, as Pandas
                                    <br/># is a mix of Python and SQL. By the end of the day, youll be able to analyze and work with
                                    <br/># tabular data in a more efficient way than other traditional methods.
                                    <br/>
                                    <br/>
                                    <br/># What Is Pandas?
                                    <br/># Pandas is a flexible data analysis library built within the C language, which is excellent
                                    <br/># for working with tabular data. It is currently the de facto standard for Python-based data
                                    <br/># analysis, and fluency in Pandas will do wonders for your productivity and frankly your
                                    <br/># resume. It is one of the fastest ways of getting from zero to answer. Having been written
                                    <br/># in C, it has increased speed when performing calculations. The Pandas module is a high
                                    <br/># performance, highly efficient, and high-level data analysis library. It allows us to work
                                    <br/># with large sets of data called DataFrames.
                                    <br/>
                                    <br/>
                                    <br/># Note NumPy is a fundamental package for scientific computing in Python. Built
                                    <br/># from the C language, it uses multidimensional arrays and can perform calculations
                                    <br/># at high-rate speeds.
                                    <br/>
                                    <br/># The Pandas library is useful in so many ways that you can do any of the following
                                    <br/># and more:
                                    <br/>#  Calculate statistics and answer questions about the data like average,
                                    <br/># median, max, and min of each column
                                    <br/>#  Finding correlations between columns
                                    <br/>#  Tracking the distribution of one or more columns
                                    <br/>#  Visualizing the data with the help of matplotlib, using plot bars,
                                    <br/># histograms, etc.
                                    <br/>#  Cleaning and filtering data, whether its missing or incomplete, just
                                    <br/># by applying a user-defined function (UDF) or built-in function
                                    <br/>#  Transforming tabular data into Python to work with
                                    <br/>#  Exporting the data into a CSV, other file, or database
                                    <br/>#  Feature engineer new columns that can be applied to your analysis
                                    <br/># No matter what you need to do with data, Pandas is your end-all-be-all
                                    <br/># analysis library.
                                    <br/>
                                    <br/>
                                    <br/># The following are key terms well be using throughout this section. Be sure to look over
                                    <br/># them and reference them when necessary:
                                    <br/>#  Series  One-dimensional labeled array capable of holding data of
                                    <br/># any type
                                    <br/>#  DataFrame  Spreadsheet
                                    <br/>#  Axis  Column or row, axis = 0 by row; axis = 1 by column
                                    <br/>#  Record  A single row
                                    <br/>#  dtype  Data type for DataFrame or series object
                                    <br/>#  Time Series  Series object that uses time intervals, like tracking weather by the hour
                                    <br/></p>
                                <br/>
                                <br/># Import pandas
                                <br/>
                                <br/>import pandas as pd
                                <br/>
                                <br/># Creating a DataFrame
                                <br/>
                                <br/># using the from_dict method to convert a dictionary into a Pandas DataFrame
                                <br/>
                                <br/>import random
                                <br/>
                                <br/>random.seed(3) # generate same random numbers every time, number used doesn't matter
                                <br/>
                                <br/>names = ["Jess", "Jordan", "Sandy", "Ted", "Barney", "Tyler", "Rebecca"]
                                <br/>
                                <br/>ages = [random.randint(18, 35) for x in range(len(names))]
                                <br/>
                                <br/>people = {"names": names, "ages": ages}
                                <br/>df = pd.DataFrame.from_dict(people)
                                <br/>print(df)
                                <br/>
                                <br/># Accessing data
                                <br/>
                                <br/># directly selecting a column in Pandas
                                <br/>
                                <br/>print(df["ages"])
                                <br/>print(df["ages"][3])
                                <br/># print( df[4] ) # doesn't work, 4 is not a column name
                                <br/>
                                <br/>
                                <br/># Indexing by Record
                                <br/>
                                <br/># When you need to access an entire record, you must use loc. This allows us to specify the
                                <br/># record location via the index. Lets access the entire first record, then the name within
                                <br/># that record:
                                <br/>
                                <br/># directly selecting a record in Pandas using .loc
                                <br/>print(df.loc[0])
                                <br/>print(df.loc[0]["names"])
                                <br/>
                                <br/># selecting the value at record 0 in the "names" column
                                <br/>
                                <br/># Slicing a dataframe
                                <br/>
                                <br/># When you want to access a specific number of records, you must slice the DataFrame.
                                <br/># Slicing in Pandas works the exact same way as a Python list does, using start, stop, and
                                <br/># step within a set of brackets.
                                <br/>
                                <br/># slicing a DataFrame to grab specific records
                                <br/>print(df[2:5])
                                <br/>
                                <br/># head( )
                                <br/># When you work with large sets of data, youll often want to view a couple records to get
                                <br/># an idea of what youre looking at. To see the top records in the DataFrame, along with the
                                <br/># column names, you use the head() method:
                                <br/>
                                <br/>
                                <br/># accessing the top 5 records using .head( )
                                <br/>print(df.head(5))
                                <br/>
                                <br/># tail( )
                                <br/>
                                <br/># To view a given number of records from the bottom, you would use the tail() method:
                                <br/># # accessing the bottom 3 records using .tail( )
                                <br/>print(df.tail(3))
                                <br/>
                                <br/># keys( )
                                <br/># Sometimes youll need the column names. Whether youre making a modular script or
                                <br/># analyzing the data youre working with, using the keys( ) method will help:
                                <br/># # accessing the column headers (keys) using the .keys( ) method
                                <br/>headers = df.keys()
                                <br/>print(headers)
                                <br/>
                                <br/># .shape
                                <br/># The shape of a DataFrame describes the number of records by the number of columns.
                                <br/># Its always important to check the shape to ensure youre working with the proper
                                <br/># amount of data:
                                <br/># checking the shape, which is the number of records and columns
                                <br/>print(df.shape)
                                <br/>
                                <br/># describe( )
                                <br/># The describe method will give you a base analysis for all numerical data. Youll be able
                                <br/># to view min, max, 25%, 50%, mean, etc., on all columns just by calling this method on the
                                <br/># DataFrame. This information is helpful to start your analysis but generally wont answer
                                <br/># those questions youre looking for. Instead, we can use this method as a guideline of
                                <br/># where to start:
                                <br/>
                                <br/># # checking the general statistics of the DataFrame using .describe( ),
                                <br/># only works on numerical columns
                                <br/>print(df.describe())
                                <br/>
                                <br/># sort_values( )
                                <br/># When you need to sort a DataFrame based on column information, you use this method.
                                <br/># You can pass in one or multiple columns to be sorted by. When passing multiple, you must
                                <br/># pass them in as a list of column names, in which the first name will take precedence:
                                <br/># # sort based on a given column, but keep the DataFrame in tact using sort_values( )
                                <br/>df = df.sort_values("ages")
                                <br/>print(df.head(5))
                                <br/>
                                <br/># Filtration
                                <br/># Lets look at how to filter DataFrames for information that meets a specific condition.
                                <br/>
                                <br/># Conditionals
                                <br/># Rather than filtering out information, we can create a boolean data type column that
                                <br/># represents the condition were checking. Lets take our current DataFrame and write a
                                <br/># condition that shows those who are 21 or older and can drink:
                                <br/># # using a conditional to create a true/false column to work with
                                <br/>can_drink = df["ages"] > 21
                                <br/>print(can_drink)
                                <br/>
                                <br/># Sub-setting
                                <br/># When you need to filter out records but retain the information within the DataFrame
                                <br/># you need to use a concept called sub-setting. Well use the same condition as earlier,
                                <br/># except this time well use it to filter out records rather than create a true-false
                                <br/># representation:
                                <br/>
                                <br/># using sub-setting to filter out records and keep DataFrame intact
                                <br/>print(df[df["ages"] > 21])
                                <br/>
                                <br/># Column Transformations
                                <br/># Rarely, if ever, will the columns in the original raw DataFrame imported from CSV or a
                                <br/># database be the ones you need for your analysis. You will spend lots of time constantly
                                <br/># transforming columns or groups of columns using general computational operations to
                                <br/># produce new ones that are functions of the old ones. Pandas has full support for this and
                                <br/># does it efficiently.
                                <br/>
                                <br/>
                                <br/># Generating a New Column with Data
                                <br/># To create a new column within a DataFrame, you use the same syntax as if you were
                                <br/># adding a new key-value pair into a dictionary. Lets create a column of fake data that
                                <br/># represents how long the people within our DataFrame have been customers with our
                                <br/># company:
                                <br/># generating a new column of fake data for each record in the DataFrame to represent customer tenure
                                <br/>random.seed(321)
                                <br/>tenure = [random.randint(0, 10) for x in range(len(df))]
                                <br/>df["tenure"] = tenure <span class="tab"></span># same as adding a new key-value pair in a dictionary
                                <br/>print(df.head())
                                <br/>
                                <br/>
                                <br/># apply( )
                                <br/>
                                <br/># Adding new columns based on current data is known as feature engineering. It
                                <br/># makes up a good portion of a data analysts job. Often, you wont be able to answer the
                                <br/># questions you have from the data you collect. Instead, you need to create your own data
                                <br/># that is useful to answering questions. For this example, lets try to answer the following
                                <br/># question: What age group does each customer belong to?. You could look at the persons
                                <br/># age and assume their age group; however, we want to make it easier than that. In order to
                                <br/># answer this question easily, well need to feature engineer a new column that represents
                                <br/># each customers age group. We can do this by using the apply method on the DataFrame.
                                <br/># The apply method takes in each record, applies the function passed, and sets the value
                                <br/># returned as the new column data. Lets check it out:
                                <br/>
                                <br/># feature engineering a new column from known data using a UDF
                                <br/>def ageGroup(age):
                                <br/><span class="tab"></span>return "Teenager" if age
                                < 21 else "Adult" <br/>
                                <br/>
                                <br/>df["age_group"] = df["ages"].apply(ageGroup)
                                <br/><span class="tab"></span>print(df.head(10))
                                <br/>
                                <br/># Aggregations
                                <br/># The raw data plus transformations is generally only half the story. Your objective is
                                <br/># to extract actual insights and actionable conclusions from the data, and that means
                                <br/># reducing it from potentially billions of rows to a summary of statistics via aggregation
                                <br/># functions. This section assumes some knowledge of SQL and the group-by function.
                                <br/># If youre not familiar with how group-by works in SQL, visit w3schools3 for reference material.
                                <br/>
                                <br/>
                                <br/># groupby()
                                <br/># In order to condense the information down to a summary of statistics, well need to use
                                <br/># the groupby method that Pandas has. Whenever you group information together, you
                                <br/># need to use an aggregate function to let the program know how to group the information
                                <br/># together. For now, lets count how many records of each age group there are within our
                                <br/># DataFrame:
                                <br/>
                                <br/># grouping the records together to count how many records in each group
                                <br/>print(df.groupby("age_group", as_index=False).count().head())
                                <br/>
                                <br/># mean( )
                                <br/># Instead of counting how many records there are in each category, lets go ahead and find
                                <br/># the averages of each column by using the mean method. Well group based on the same
                                <br/># column:
                                <br/>
                                <br/># grouping the data to see averages of all columns
                                <br/>print(df.groupby("age_group", as_index=False).mean().head())
                                <br/>
                                <br/># groupby( ) with Multiple Columns
                                <br/># When you need to group by multiple columns, the arguments must be passed in as a list.
                                <br/># The first item in the list will be the main column that the DataFrame is grouped by. In
                                <br/># our case, lets check how many adults have a tenure of five years:
                                <br/>
                                <br/># grouping information by their age group, then by their tenure
                                <br/>print(df.groupby(["age_group", "tenure"], as_index=False).count().head(10))
                                <br/>
                                <br/># Adding a record
                                <br/># To add a record into the DataFrame, youll need to access the next index and assign a value as
                                <br/># a list structure. In our case, the next index would be 7. Lets add an identical row that already
                                <br/># exists in our DataFrame, so we can see how to remove duplicate information in the next cell:
                                <br/>
                                <br/># adding a record to the bottom of the DataFrame
                                <br/>df.loc[7] = [25, "Jess", 2, "Adult"]
                                <br/>
                                <br/># add a record
                                <br/>print(df.head(10))
                                <br/>
                                <br/># drop_duplicates( )
                                <br/># Way too often will you see data with duplicate information, or just duplicate IDs. Its
                                <br/># imperative that you remove all duplicate records as it will skew your data, resulting
                                <br/># in incorrect answers. You can remove duplicate records based on a single column or
                                <br/># an entire record being identical. In our case, lets remove duplicates based on similar
                                <br/># names, which will remove the record we just added into our DataFrame:
                                <br/>
                                <br/>
                                <br/># removing duplicates based on same names
                                <br/>df = df.drop_duplicates(subset="names")
                                <br/>print(df.head(10))
                                <br/>
                                <br/># Omitting the subset argument will remove only duplicate records that have
                                <br/># identical values in all columns.
                                <br/>
                                <br/>
                                <br/># Pandas Joins
                                <br/># Often, you will have to combine data from several different sources to obtain the actual
                                <br/># dataset you need for your exploration or modeling. Pandas draws heavily on SQL in its
                                <br/># design for joins.
                                <br/>
                                <br/># Creating a Second DataFrame
                                <br/># Lets create a secondary DataFrame to represent our customers posting ratings about
                                <br/># our company. Well create ratings for three users so we can see both inner joins and
                                <br/># outer joins:
                                <br/># # creating another fake DataFrame to work with, having same names and a
                                <br/># new ratings column
                                <br/>ratings = {
                                <br/><span class="tab"></span>"names": ["Jess", "Tyler", "Ted"],
                                <br/><span class="tab"></span>"ratings": [10, 9, 6]
                                <br/>}
                                <br/>ratings = df.from_dict(ratings)
                                <br/>ratings.head()
                                <br/>
                                <br/>
                                <br/># Inner Join
                                <br/># Anytime you perform a join, you need a unique column to join the data with. In our
                                <br/># case, we can use the names column to join the ratings DataFrame with our original
                                <br/># DataFrame.
                                <br/>
                                <br/># performing an inner join with our df and ratings DataFrames based on names, get data that matches
                                <br/>matched_ratings = df.merge(ratings, on="names", how="inner")
                                <br/>print(matched_ratings.head())
                                <br/>
                                <br/>
                                <br/># Outer Join
                                <br/># If we want to return all the records, but connect the ratings for people who gave one,
                                <br/># we would need to perform an outer join. This would allow us to keep all records from
                                <br/># our original DataFrame while adding the ratings column. We need to specify the how
                                <br/># parameter to outer:
                                <br/>
                                <br/># performing an outer join with our df and ratings DataFrames based on names, get all data
                                <br/>all_ratings = df.merge(ratings, on="names", how="outer")
                                <br/>print(all_ratings.head())
                                <br/>
                                <br/>
                                <br/># Dataset Pipeline
                                <br/># A dataset pipeline is a specific process in which we take our data and clean it for our
                                <br/># model, which will be able to make predictions. This can be a lengthy process if the
                                <br/># dataset that you use is unclean. A dataset that is not clean will have duplicates records,
                                <br/># null values everywhere, or unfiltered information that leads to incorrect predictions.
                                <br/># Here is the general process:
                                <br/>
                                <br/>
                                <br/># 1. Performing Exploratory Analysis
                                <br/>#  In this step you want to get to know your data very well. Take
                                <br/># notes for what you see at a glance or what you may want to clean
                                <br/># or add. You essentially want to get a feel for what your data has
                                <br/># to offer. Make note of the number of columns, the data types,
                                <br/># outliers, null values, and columns that arent necessary. This is
                                <br/># generally when you want to plot out each column of data and
                                <br/># speculate correlations, non-informational features, etc.
                                <br/>
                                <br/>
                                <br/># 2. Data Cleaning
                                <br/>#  Improper cleaning can lead to poor predictions and bad
                                <br/># datasets. Here, youll want to remove unwanted observations
                                <br/># like duplicates, fix structural errors like columns that have the
                                <br/># same name but are typos, handle missing data, and filter outlier
                                <br/># information. This is key for the next step.
                                <br/>
                                <br/>
                                <br/># 3. Feature Engineering
                                <br/>#  Creating new information that isnt depicted by the dataset is
                                <br/># important. You can use your own expertise if you have knowledge
                                <br/># of the subject, and you can isolate data which allows your
                                <br/># algorithms to focus more on the important observations. Here
                                <br/># you can feature engineer columns into a group, add dummy
                                <br/># variables, remove unused features, etc. This is where you want to
                                <br/># expand on the dataset with your own knowledge if you believe
                                <br/># data is either missing or could be created from the information
                                <br/># within the dataset.
                                <br/>
                                <br/>
                                <br/>import pandas as pd
                                <br/>
                                <br/># Creating a DataFrame
                                <br/>import csv
                                <br/>
                                <br/># f = open("top250.csv", "r")
                                <br/># data = f.read()
                                <br/># f.close()
                                <br/># print(data)
                                <br/>
                                <br/>with open("top250.csv", mode="r") as f:
                                <br/><span class="tab"></span>reader = csv.reader(f)
                                <br/><span class="tab"></span>df = pd.DataFrame.from_dict(reader)
                                <br/>
                                <br/><span class="tab"></span>print(df)
                                <br/>
                                <br/># 1: print top 5 data
                                <br/>top5 = df.head(5)
                                <br/>print("\n\n\n", top5)
                                <br/>
                                <br/># how many records are there
                                <br/>print(df.shape)
                                <br/>
                                <br/># data types of each column
                                <br/>print(df.dtypes)
                                <br/>
                                <br/># are there duplicates
                                <br/>duplicateRows = df.duplicated()
                                <br/>print(duplicateRows)
                                <br/>
                                <br/># find null data
                                <br/>print(df.isnull)
                                <br/>
                                <br/># Is there a correlation between two or more columns?
                                <br/>print(df.corr())
                                <br/>
                                <br/># data visualisation
                                <br/>
                                <br/>import numpy
                                <br/>
                                <br/># Data visualization is one of the most powerful tools an analyst has for two main reasons.
                                <br/># Firstly, it is unrivalled in its ability to guide the analysts hand in determining what
                                <br/># to look at next. Often, a visual is revealing of patterns in the data that are not easily
                                <br/># discernable by just looking at DataFrames. Secondly, they are an analysts greatest
                                <br/># communication tool. Professional analysts need to present their results to groups of
                                <br/># people responsible for acting based on what the data says. Visuals can tell your story
                                <br/># much better than raw numbers.
                                <br/>
                                <br/># Types of Charts
                                <br/># Knowing which chart to use is important in presenting your data properly. Well go over
                                <br/># several charts today; however, these are some of the common charts youll want to know:
                                <br/>#  Line Chart: Exploring data over time
                                <br/>#  Bar Chart: Comparing categories of data and tracks changes over
                                <br/># time
                                <br/>#  Pie Chart: Explores parts of a whole, that is, fractions
                                <br/>#  Scatter Plot: Like line charts, tracks correlations between two
                                <br/># categories
                                <br/>#  Histogram: Unrelated from bar charts, shows distribution of
                                <br/># variables
                                <br/>#  Candlestick Chart: Used a lot in financial sector, that is, can compare
                                <br/># a stock over a period
                                <br/>#  Box Chart: Looks identical to candlestick charts, and compares
                                <br/># minimum, 1st, median, 3rd quartiles, and max values
                                <br/># Depending on what you need to accomplish in conceptualizing your data, you will
                                <br/># be able to choose a specific type of chart to portray your data.
                                <br/>
                                <br/>from matplotlib import pyplot as plt
                                <br/>
                                <br/># Creating a line plot using x and y coordinates
                                <br/>x, y = [1600, 1700, 1800, 1900, 2000], [0.2, 0.5, 1.1, 2.2, 7.7]
                                <br/>
                                <br/>plt.plot(x, y) # creates the line
                                <br/>
                                <br/>plt.title("World Population Over Time")
                                <br/>plt.xlabel("Year")
                                <br/>plt.ylabel("Population (billions)")
                                <br/>plt.show()
                                <br/>
                                <br/># Creating line plot with multiple lines
                                <br/>
                                <br/>x1, y1 = [1600, 1700, 1800, 1900, 2000], [0.2, 0.5, 1.1, 2.2, 7.7]
                                <br/>x2, y2 = [1600, 1700, 1800, 1900, 2000], [1, 1, 2, 3, 4]
                                <br/>plt.plot(x1, y1, "rx-", label="Actual") # create a red solid line with x dots
                                <br/>plt.plot(x2, y2, "bo--", label="Fake") # create a blue dashed line with circle dots
                                <br/>
                                <br/>plt.title("World Population Over Time")
                                <br/>plt.xlabel("Year")
                                <br/>plt.ylabel("Population (billions)")
                                <br/>plt.legend() # shows labels in best corner
                                <br/>plt.show()
                                <br/>
                                <br/>
                                <br/># creating a bar plot using x and y coordinates
                                <br/>num_people, categories = [ 4, 8, 3, 6, 2 ] , [ "Comedy", "Action", "Thriller", "Romance", "Horror" ]
                                <br/>plt.bar(categories, num_people)
                                <br/>plt.title("Favorite Movie Category", fontsize=24)
                                <br/>plt.xlabel("Category", fontsize=16)
                                <br/>plt.ylabel("# of People", fontsize=16)
                                <br/>plt.xticks(fontname="Fantasy")
                                <br/>plt.yticks(fontname="Fantasy")
                                <br/>plt.show()
                                <br/>
                                <br/>
                                <br/>
                                <br/># Box Plot
                                <br/># Box plots are useful in situations where you need to compare a single statistic either
                                <br/># over time or against categories. They are like candlestick charts in their design, where
                                <br/># you can view the min, max, 25% quartile, 75% quartile, and median, which can be useful
                                <br/># for displaying data over time. In the case of stocks, currency would be the y axis data
                                <br/># and time would be the x axis data. For our example, lets create two separate groups and
                                <br/># display the heights for each:
                                <br/>
                                <br/>
                                <br/># creating a box plot  showing height data for male-female
                                <br/>males, females = [72, 68, 65, 77, 73, 71, 69], [60, 65, 68, 61, 63, 64]
                                <br/>heights = [males, females]
                                <br/>plt.figure(figsize=(15, 8)) # makes chart bigger
                                <br/>plt.boxplot(heights) # takes in list of data, each box is its own array, heights contains two lists
                                <br/>
                                <br/>plt.xticks([1, 2], ["Male", "Female "]) # # sets number of ticks and labels on x-axis
                                <br/>plt.title("Height by Gender", fontsize=22)
                                <br/>plt.ylabel("Height (inches)", fontsize=14)
                                <br/>plt.xlabel("Gender", fontsize=14)
                                <br/>plt.show()
                                <br/>
                                <br/># Scatter Plot
                                <br/># If youre familiar with clusters, then youll know the importance of scatter plots.
                                <br/># These types of plots help to distinguish groups apart from each other by plotting a
                                <br/># dot for each set of data. Using two characteristics, like height and width of a flower,
                                <br/># we can classify which species a flower belongs to. Lets create some fake data and
                                <br/># plot the points:
                                <br/>
                                <br/>import random
                                <br/>
                                <br/>from matplotlib import pyplot as plt
                                <br/>
                                <br/># creating a scatter plot to represent height-weight distribution
                                <br/>
                                <br/>random.seed(2)
                                <br/>height = [random.randint(58, 78) for x in range(20)]
                                <br/>
                                <br/>weight = [random.randint(90, 250) for x in range(20)]
                                <br/>
                                <br/>plt.scatter(weight, height)
                                <br/>plt.title("Height-Weight Distribution")
                                <br/>plt.xlabel("Weight (lbs)")
                                <br/>plt.ylabel("Height (inches)")
                                <br/>plt.show()
                                <br/>
                                <br/># Histogram
                                <br/># While line plots are great for visualizing trends in time series data, histograms are the
                                <br/># king of visualizing distributions. Often, the distribution of a variable is what youre
                                <br/># interested in, and a visualization provides a lot more information than a group of
                                <br/># summary statistics. First, lets see how we can create a histogram:
                                <br/>
                                <br/># creating a histogram to show age data for a fake population
                                <br/>
                                <br/>import numpy as np
                                <br/>
                                <br/># import the numpy module to generate data
                                <br/>np.random.seed(5)
                                <br/>
                                <br/>ages = [np.random.normal(loc=40, scale=10) for x in range(1000)] # ages distributed around 40
                                <br/>
                                <br/>plt.hist(ages, bins=45) # bins is the number of bars
                                <br/>plt.title("Ages per Population")
                                <br/>plt.xlabel("Age")
                                <br/>plt.ylabel("# of People")
                                <br/>plt.show()
                                <br/>
                                <br/># Importance of Histogram Distribution
                                <br/># To see why histograms are so important with understanding central distribution, well
                                <br/># need to create some more fake data. Well then plot both datasets and see how they
                                <br/># stack up:
                                <br/>
                                <br/>
                                <br/># showing the importance of histogram's display central distribution
                                <br/>florida = [np.random.normal(loc=60, scale=15) for x in range(1000)]
                                <br/>
                                <br/># assume numpy is imported
                                <br/>california = [np.random.normal(loc=35, scale=5) for x in range(1000)]
                                <br/># chart 1
                                <br/>plt.hist(florida, bins=45, color="r", alpha=0.4)
                                <br/>
                                <br/># alpha is opacity, making it see through
                                <br/>plt.show()
                                <br/># chart 2
                                <br/>plt.hist(california, bins=45, color="b", alpha=0.4)
                                <br/>
                                <br/># alpha is opacity, making it see through plt.show()
                                <br/># chart 3
                                <br/>plt.hist(florida, bins=45, color="r", alpha=0.4)
                                <br/>
                                <br/>plt.hist(california, bins=45, color="b", alpha=0.4)
                                <br/>
                                <br/># alpha is opacity,
                                <br/>
                                <br/>plt.show()
                                <br/>
                                <br/># When rendering several charts, matplotlib understands how to separate
                                <br/># each plot by resetting the chart to empty after the show method is run, until then
                                <br/># all information being plotted will be included in one chart.
                                <br/>
                                <br/># Saving the Chart
                                <br/># Being able to render these charts is wonderful; however, at times you need to use them
                                <br/># within a presentation. Luckily for us, matplotlib comes with a method that can save the
                                <br/># charts we create to a file. The savefig() method supports many different file extensions;
                                <br/># the most common .jpg is what well use. Lets render a simple plot line chart to the local
                                <br/># folder:
                                <br/>
                                <br/># using savefig method to save the chart as a jpg to the local folder
                                <br/>x, y = [1600, 1700, 1800, 1900, 2000], [0.2, 0.5, 1.1, 2.2, 7.7]
                                <br/>
                                <br/>plt.plot(x, y, "bo-")
                                <br/>plt.title("World Population Over Time")
                                <br/>
                                <br/>plt.xlabel("Year")
                                <br/>plt.ylabel("Population (billions)")
                                <br/># plt.savefig("population.png")
                                <br/>
                                <br/># Note You can save the chart in other formats like PDF or PNG.
                                <br/>
                                <br/>
                                <br/># Flattening Multidimensional Data
                                <br/># Generally, in data analysis you want to avoid 3D plotting wherever possible. Its not
                                <br/># because the information you want to convey isnt contained within the result, but
                                <br/># sometimes it is simply easier to express a point by other means. One of the best ways to
                                <br/># represent a third dimension is to use color instead of depth.
                                <br/># For instance, imagine that you have three datasets that you need to plot: height,
                                <br/># weight, and age. You could render a 3D model, but that would be excessive. Instead,
                                <br/># you can render the height and weight like we have before on a scatter plot and color
                                <br/># each dot to represent the age. The third dimension of color is now easily readable rather
                                <br/># than trying to depict the data using the z axis (depth). Lets create this exact scatter plot
                                <br/># together in the following:
                                <br/>
                                <br/># creating a scatter plot to represent height-weight distribution
                                <br/>
                                <br/>random.seed(2)
                                <br/>height = [random.randint(58, 78) for x in range(20)]
                                <br/>weight = [random.randint(90, 250) for x in range(20)]
                                <br/>age = [random.randint(18, 65) for x in range(20)]
                                <br/>plt.scatter(weight, height, c=age)
                                <br/>plt.title("Height-Weight Distribution")
                                <br/>plt.xlabel("Weight (lbs)")
                                <br/>plt.ylabel("Height (inches)")
                                <br/>plt.colorbar(label="Age") # adds color bar to right side
                                <br/>plt.show()
                                <br/>
                                <br/>
                                <br/># Thursday: Web Scraping
                                <br/># You may have heard the term web scraping previously. In most languages like Python,
                                <br/># web scraping is comprised of two parts: sending out a request and parsing the data. Well
                                <br/># need to use the requests module for the first part and a library called Beautiful Soup for
                                <br/># the second part. In a nutshell, the script you write to request data and parse it is called a
                                <br/># scraper.
                                <br/>
                                <br/>
                                <br/># importing the beautiful soup and requests library
                                <br/>from bs4 import BeautifulSoup
                                <br/>import requests
                                <br/>
                                <br/># Requesting Page Content
                                <br/># To begin scraping data, lets send a request to a simple web page that contains only
                                <br/># a poem:
                                <br/># performing a request and outputting the status code
                                <br/>
                                <br/>page = requests.get("http://www.arthurleej.com/e-love.html")
                                <br/>print(page)
                                <br/>
                                <br/># outputting the request response content
                                <br/>print(page.content)
                                <br/>
                                <br/># Parsing the Response with Beautiful Soup
                                <br/>
                                <br/># The Beautiful Soup library comes with many attributes and methods that make
                                <br/># parsing the code easier for ourselves. Using this library, we can make the code easy
                                <br/># to view, scrape, and traverse through. Well need to create a BeautifulSoup object to
                                <br/># work with by passing the page content into it, along with the type of parser we want
                                <br/># to use. In our case, were working with HTML code, so well need to use the HTML
                                <br/># parser:
                                <br/>
                                <br/>
                                <br/># turning the response into a BeautifulSoup object to extract data
                                <br/>soup = BeautifulSoup(page.content, "html.parser")
                                <br/>print(soup.prettify())
                                <br/>
                                <br/># Scraping Data
                                <br/># There are many methods to extract data using Beautiful Soup. The following sections will
                                <br/># cover a few of the main methods in doing so. Basic HTML knowledge is assumed for this
                                <br/># section.
                                <br/>
                                <br/># .find( )
                                <br/># To find a specific element within the code, we can use the find() method. The argument
                                <br/># we pass is the tag that we want to search for, but it will only find the first instance and
                                <br/># return it. Meaning that if there are four bold element tags within our code, and we use
                                <br/># this method to find a bold tag, it will respond back with only the first bold element tag
                                <br/># found. Lets try it out:
                                <br/>
                                <br/># using the find method to scrape the text within the first bold tag
                                <br/>title = soup.find("b")
                                <br/>print(title)
                                <br/>print(title.get_text) # extracts all text within element
                                <br/>
                                <br/># .find_all( )
                                <br/># To find all instances of a given element, we use the find_all() method. This will give us
                                <br/># back a list of all tags found within the code. Lets find all bold tags within the code and
                                <br/># extract the text:
                                <br/># get all text within the bold element tag then output each
                                <br/>poem_text = soup.find_all("b")
                                <br/>for text in poem_text:
                                <br/>print(text.get_text())
                                <br/>
                                <br/>
                                <br/># Finding Elements by Attributes
                                <br/># All HTML elements have attributes associated with them, whether its a style, id, class,
                                <br/># etc., you can use Beautiful Soup to find elements with a specific attribute value. Lets
                                <br/># request a response from my personal Github page and find the element that shows my
                                <br/># username:
                                <br/>
                                <br/># finding an element by specific attribute key-values
                                <br/>page = requests.get("https://github.com/Connor-SM")
                                <br/>soup = BeautifulSoup(page.content, "html.parser")
                                <br/>username = soup.find("span", attrs={"class": "vcard-username"}) # find first span with this class
                                <br/>print(username) # will show that element has class of vcard-username
                                <br/>print(username.get_text)
                                <br/>
                                <br/># Finding elements by attributes also works with the find_all method. You can
                                <br/># also include multiple key-value pairs to look for within the attrs argument.
                                <br/>
                                <br/>
                                <br/># DOM Traversal
                                <br/># This section will cover how to extract information by traversing through the DOM
                                <br/># hierarchy. The DOM, short for Document Object Model, is a concept in web design that
                                <br/># describes the relationships and structure between elements on a browser. All elements
                                <br/># on a web page belong to one of three relationships:
                                <br/># 1. Parent-Child
                                <br/># 2. Sibling
                                <br/># 3. Grandparent-Grandchild
                                <br/>
                                <br/>
                                <br/># traversing through the DOM using Beautiful Soup  using the children attribute
                                <br/>page = requests.get("http://www.arthurleej.com/e-love.html")
                                <br/>soup = BeautifulSoup(page.content, "html.parser")
                                <br/>print(soup.children) # outputs an iterator object
                                <br/>
                                <br/>
                                <br/># Understanding the Types of Children
                                <br/># Before we begin, we first need to understand the types of children within the
                                <br/># BeautifulSoup object. Lets convert the iterator into a list of elements that we can
                                <br/># loop over:
                                <br/>
                                <br/># understanding the children within the soup object
                                <br/>for child in list(soup.children):
                                <br/><span class="tab"></span>print(type(child))
                                <br/>
                                <br/>
                                <br/># accessing the .Tag object which holds the html  trying to access the title tag
                                <br/>
                                <br/>html = list(soup.children)[2]
                                <br/>for section in html:
                                <br/><span class="tab"></span>print("\n\n Start of new section")
                                <br/><span class="tab"></span>print(section)
                                <br/>
                                <br/>
                                <br/># Accessing the Head Element Tag
                                <br/># Now that we know the head element is at index 1 of the HTML children,
                                <br/># we can perform the same execution to access each child within the head
                                <br/>
                                <br/># accessing the head element using the children attribute
                                <br/>head = list(html.children)[1]
                                <br/>for item in head:
                                <br/><span class="tab"></span>print("\n\n New Tag")
                                <br/><span class="tab"></span>print(item)
                                <br/>
                                <br/># Remember that each object stored in these variables is an iterator and can
                                <br/># be type converted into lists.
                                <br/>
                                <br/>
                                <br/># Scraping the Title Text
                                <br/># The final step is to extract the text from the title tag:
                                <br/>
                                <br/># scraping the title text
                                <br/>title = list(head)[1]
                                <br/>print(title.string) # .string is used to extract text as well
                                <br/>print(type(title.string)) # results in NavigableString
                                <br/>print(title.get_text())
                                <br/>
                                <br/># The ability to access an objects children elements allows us to create
                                <br/># modular or automated web scrapers that can perform a various number of tasks.
                                <br/># As most sites follow a similar style on their web pages, creating a script that
                                <br/># would extract information on a single page would allow us to do so on many
                                <br/># other pages if we knew the proper pattern. For instance, the online statistical
                                <br/># database for baseball called baseball-reference holds data for all baseball players
                                <br/># throughout the history of the MLB.Each player has a unique identifier on the web
                                <br/># sites URL. If you wrote a parsing script that would extract information for one
                                <br/># player, you would be able to write a loop to extract information from all players in
                                <br/># the database.
                                <br/>
                                <br/>
                                <br/>import random
                                <br/>from matplotlib import pyplot as plt
                                <br/>
                                <br/>random.seed(2)
                                <br/>L1 = [random.randint(1,10) for x in range(20)]
                                <br/>print(L1)
                                <br/>L2 = [random.randint(1,10) for x in range(20)]
                                <br/>print(L2)
                                <br/>L3 = [random.randint(1,10) for x in range(20)]
                                <br/>print(L3)
                                <br/>plt.plot(L1, "r-.", label="list_1")
                                <br/>plt.plot(L2, "g-o", label="list_2")
                                <br/>plt.plot(L3, "y-*", label="list_3")
                                <br/>plt.legend()
                                <br/>plt.show()
                                <br/>
                                <br/>
                                <br/># FRIDAY PROJECT
                                <br/>
                                <br/># importing libraries
                                <br/>
                                <br/>import requests
                                <br/>import matplotlib.pyplot as plt
                                <br/>from bs4 import BeautifulSoup
                                <br/>from bs4 import Comment
                                <br/>
                                <br/>
                                <br/># graph results of top 7 words
                                <br/>def displayResults(words, site):
                                <br/><span class="tab"></span>count = [item[1] for item in words][::-1] # reverses order
                                <br/><span class="tab"></span>word = [item[0] for item in words][::-1] # reverses order
                                <br/>
                                <br/><span class="tab"></span>plt.figure(figsize=(20, 10)) # define how large the figure appears
                                <br/>
                                <br/><span class="tab"></span>plt.bar(word, count)
                                <br/>
                                <br/><span class="tab"></span>plt.title("Analyzing Top Words from: {}...".format(site[:50]), fontname="Sans Serif", fontsize=24)
                                <br/><span class="tab"></span>plt.xlabel("Words", fontsize=24)
                                <br/><span class="tab"></span>plt.ylabel("# of Appearances", fontsize=24)
                                <br/><span class="tab"></span>plt.xticks(fontname="Sans Serif", fontsize=20)
                                <br/><span class="tab"></span>plt.yticks(fontname="Sans Serif", fontsize=20)
                                <br/>
                                <br/><span class="tab"></span>plt.savefig('microsoft.png')
                                <br/><span class="tab"></span>plt.show()
                                <br/>
                                <br/>
                                <br/># filter article words and hidden characters
                                <br/>def filterWaste(word):
                                <br/><span class="tab"></span>bad_words = (
                                <br/><span class="tab"></span>'the', 'a', 'in', 'of', 'to', 'you', '\xa0', 'and', 'at', 'on', 'for', 'from', 'is', 'that', 'are', 'be', '-', 'as',
                                <br/><span class="tab"></span>'&', 'they', 'with',
                                <br/><span class="tab"></span>'how', 'was', 'her', 'him', 'i', 'has', '|', 'his')
                                <br/>
                                <br/><span class="tab"></span>if word.lower() in bad_words:
                                <br/><span class="tab"></span><span class="tab"></span>return False
                                <br/><span class="tab"></span>else:
                                <br/><span class="tab"></span><span class="tab"></span>return True
                                <br/>
                                <br/>
                                <br/># filter out all elements that do not contain text that appears on site
                                <br/>def filterTags(element):
                                <br/><span class="tab"></span>if element.parent.name in ['style', 'script', 'head', 'title', 'meta', '[document]']:
                                <br/><span class="tab"></span><span class="tab"></span>return False
                                <br/>
                                <br/><span class="tab"></span>if isinstance(element, Comment):
                                <br/><span class="tab"></span><span class="tab"></span>return False
                                <br/>
                                <br/><span class="tab"></span>return True
                                <br/>
                                <br/>
                                <br/># request site and top 7 most used words
                                <br/>def scrape(site):
                                <br/><span class="tab"></span>page = requests.get(site)
                                <br/>
                                <br/><span class="tab"></span>soup = BeautifulSoup(page.content, 'html.parser')
                                <br/>
                                <br/><span class="tab"></span>text = soup.find_all(text=True) # will get all text within the document
                                <br/>
                                <br/><span class="tab"></span>visible_text = filter(filterTags, text)
                                <br/>
                                <br/><span class="tab"></span>word_count = {}
                                <br/>
                                <br/><span class="tab"></span>for text in visible_text:
                                <br/><span class="tab"></span><span class="tab"></span>words = text.replace('\n', '').replace('\t', '').split(' ') # replace all hidden chars
                                <br/>
                                <br/><span class="tab"></span>words = list(filter(filterWaste, words))
                                <br/>
                                <br/><span class="tab"></span>for word in words:
                                <br/><span class="tab"></span><span class="tab"></span>if word != '':
                                <br/><span class="tab"></span><span class="tab"></span><span class="tab"></span>if word in word_count:
                                <br/><span class="tab"></span><span class="tab"></span><span class="tab"></span>word_count[word] += 1
                                <br/><span class="tab"></span><span class="tab"></span>else:
                                <br/><span class="tab"></span><span class="tab"></span><span class="tab"></span>word_count[word] = 1
                                <br/>
                                <br/><span class="tab"></span>word_count = sorted(word_count.items(), key=lambda kv: kv[1], reverse=True)
                                <br/>
                                <br/><span class="tab"></span>return word_count[:7]
                                <br/>
                                <br/>
                                <br/># main loop should ask if user wants to scrape, then what site to scrape
                                <br/>while input('Would you like to scrape a website (y/n)? ') == 'y':
                                <br/><span class="tab"></span>try:
                                <br/><span class="tab"></span>
                                <br/><span class="tab"></span><span class="tab"></span>site = input('Enter a website to analyze: ')
                                <br/><span class="tab"></span>
                                <br/><span class="tab"></span><span class="tab"></span>top_words = scrape(site)
                                <br/><span class="tab"></span>
                                <br/><span class="tab"></span><span class="tab"></span>top_word = top_words[0] # tuple of (word, count)
                                <br/><span class="tab"></span>
                                <br/><span class="tab"></span><span class="tab"></span>print("The top word is: {}".format(top_word[0]))
                                <br/><span class="tab"></span>
                                <br/><span class="tab"></span><span class="tab"></span>displayResults(top_words, site)
                                <br/><span class="tab"></span>except:
                                <br/><span class="tab"></span><span class="tab"></span>print('Something went wrong, please try again.')
                                <br/><span class="tab"></span>
                                <br/><span class="tab"></span><span class="tab"></span>print('Thanks for analyzing! Come back again!')
                                <br/>
                                <br/># 2 Print all names of national stadiums
                                <br/>
                                <br/>import requests
                                <br/>from bs4 import BeautifulSoup
                                <br/>
                                <br/>
                                <br/>page = requests.get('https://en.wikipedia.org/wiki/List_of_current_National_Football_League_stadiums')
                                <br/>soup = BeautifulSoup(page.content, 'html.parser')
                                <br/>nfl_stadiums_table = soup.findAll('table')[1]
                                <br/>tbody = list(nfl_stadiums_table.children)[1]
                                <br/>
                                <br/>stadiums = []
                                <br/>
                                <br/>for i in range(1, len(list(tbody.children))):
                                <br/><span class="tab"></span>row = list(tbody.children)[i]
                                <br/><span class="tab"></span>th = row.find('th')
                                <br/><span class="tab"></span>try:
                                <br/><span class="tab"></span><span class="tab"></span>stadium_name = th.get_text()
                                <br/><span class="tab"></span><span class="tab"></span>stadiums.append(stadium_name)
                                <br/><span class="tab"></span>except:
                                <br/><span class="tab"></span><span class="tab"></span>pass
                                <br/>for stadium in stadiums:
                                <br/>print(stadium)
                                <br/>
                                <br/>print(len(stadiums)) # should be 31, two teams share a field</p>
                    </section>
                    <section id="about" class="main-section">
                        <header>
                            <h2>About</h2>
                        </header>
                        <p class="support-text">
                            <br />
                            <b>Special Thanks to Connor P. Milliken !!!</b>
                            <br />
                            <br />
                            <br /> Know more about <a href="https://linkedin.in/imhitesh/">Hitesh Kumar</a><br /><br/> See on <a href="https://github.com/thexcaliber">GitHub</a>
                            <br /><br /><br />Codewars Rank:<br />
                            <img id="cwars" src=https://www.codewars.com/users/thexcaliber/badges/large>
                        </p>
                    </section>

                </article>
            </main>
        </div>
    </div>
</body>

</html>